<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>菌落计数器</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f9; color: #333; }
        canvas { border: 1px solid #ccc; margin-top: 20px; max-width: 100%; }
        #loadingStatus { display: none; padding: 20px; background: #f0f0f0; border-radius: 5px; }
        #loadingBar { width: 100%; background-color: #e0e0e0; border-radius: 10px; height: 20px; margin-top: 10px; }
        #loadingProgress { width: 0%; height: 100%; background-color: #3b82f6; border-radius: 10px; }
        #toast { display: none; padding: 10px 20px; background: #ff4d4d; color: white; border-radius: 5px; margin-top: 20px; }
        #uploadCard { padding: 20px; background: #fff; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #uploadCard button { padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #uploadCard button:hover { background: #1d4ed8; }
    </style>
</head>
<body>
    <h1>菌落计数器</h1>

    <!-- 上传部分 -->
    <div id="uploadCard">
        <button onclick="loadRemoteModel()">加载远程模型（YOLO11n）</button><br><br>
        <input type="file" id="modelFileInput" accept=".onnx" style="display:none" onchange="loadLocalModel(event)">
        <button onclick="document.getElementById('modelFileInput').click()">上传本地模型</button><br><br>

        <input type="file" id="fileInput" accept="image/*" onchange="handleImageUpload(event)">
        <button onclick="document.getElementById('fileInput').click()">上传图片</button><br><br>
    </div>

    <!-- 加载状态 -->
    <div id="loadingStatus">
        <p>加载中...</p>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
    </div>

    <canvas id="mainCanvas"></canvas>

    <!-- 提示框 -->
    <div id="toast"></div>

    <script>
        let session = null;
        let modelLoaded = false;
        let currentImage = null;
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let colonies = [];

        // 错误提示和进度反馈
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => { toast.style.display = 'none'; }, 3000);
        }

        // 加载远程模型（YOLO11n）
        async function loadRemoteModel() {
            const modelUrl = 'https://github.com/ultralytics/assets/releases/download/v8.3.0/yolo11n.onnx'; 
            const backupUrls = [
                'https://huggingface.co/ultralytics/yolo11/resolve/main/yolo11n.onnx',
                'https://www.kaggle.com/models/ultralytics/yolo11/frameworks/tfJs/variations/yolo11n/versions/1?tfjs-format=onnx&tfjs-path=model.onnx'
            ];

            showLoadingStatus('正在加载模型...');
            
            try {
                await tryLoadModel(modelUrl, backupUrls);
            } catch (error) {
                showToast('❌ 模型加载失败');
                console.error(error);
            }
        }

        // 尝试加载模型，支持备用 URL
        async function tryLoadModel(url, backupUrls) {
            const urls = [url, ...backupUrls];
            
            for (let i = 0; i < urls.length; i++) {
                const modelUrl = urls[i];
                try {
                    await loadModelFromUrl(modelUrl);
                    showToast('✅ 模型加载成功');
                    return;
                } catch (error) {
                    console.warn(`加载模型失败，尝试下一个链接: ${modelUrl}`);
                    updateLoadingProgress((i + 1) / urls.length * 100);
                }
            }

            throw new Error('所有模型链接加载失败');
        }

        // 从 URL 加载模型
        async function loadModelFromUrl(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP 错误: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            session = await ort.InferenceSession.create(arrayBuffer);
            modelLoaded = true;
            updateLoadingProgress(100);
        }

        // 读取本地模型文件
        function loadLocalModel(event) {
            const file = event.target.files[0];
            if (!file || !file.name.endsWith('.onnx')) {
                showToast('❌ 请上传 .onnx 格式的模型');
                return;
            }

            const reader = new FileReader();
            reader.onload = async function() {
                try {
                    showLoadingStatus('正在加载本地模型...');
                    const arrayBuffer = reader.result;
                    session = await ort.InferenceSession.create(arrayBuffer);
                    modelLoaded = true;
                    showToast('✅ 本地模型加载成功');
                } catch (error) {
                    showToast('❌ 本地模型加载失败');
                    console.error(error);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // 显示加载进度
        function showLoadingStatus(message) {
            document.getElementById('loadingStatus').style.display = 'block';
            document.getElementById('loadingProgress').style.width = '0%';
            showToast(message);
        }

        // 更新加载进度
        function updateLoadingProgress(percentage) {
            document.getElementById('loadingProgress').style.width = `${percentage}%`;
        }

        // 处理图像上传
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                currentImage = new Image();
                currentImage.onload = () => {
                    displayImage(currentImage);
                };
                currentImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 显示图像
        function displayImage(img) {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
        }

        // 进行菌落检测
        async function analyze() {
            if (!currentImage) {
                showToast('❌ 没有图像');
                return;
            }
            if (!modelLoaded || !session) {
                showToast('⏳ 模型未加载，使用传统CV模式');
                analyzeCV(); // 如果模型加载失败，使用传统计算机视觉算法
                return;
            }

            // 预处理和推理
            try {
                const inputSize = 640;
                const tensor = await preprocessImage(currentImage, inputSize);
                const feeds = { images: tensor };
                const results = await session.run(feeds);

                const output = results.output0 || results[Object.keys(results)[0]];
                const detections = parseYOLOOutput(output, 0.25, 0.45, inputSize);

                renderMarkers(detections);
                showToast(`✅ YOLO检测到 ${detections.length} 个菌落`);
            } catch (error) {
                console.error(error);
                showToast('❌ YOLO失败，切换到CV');
                analyzeCV(); // YOLO失败时切换到传统CV模式
            }
        }

        // 图像预处理
        async function preprocessImage(img, inputSize) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = inputSize;
            tempCanvas.height = inputSize;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.drawImage(img, 0, 0, inputSize, inputSize);
            const imageData = tCtx.getImageData(0, 0, inputSize, inputSize);
            const data = imageData.data;
            const red = [], green = [], blue = [];
            for (let i = 0; i < data.length; i += 4) {
                red.push(data[i] / 255);
                green.push(data[i + 1] / 255);
                blue.push(data[i + 2] / 255);
            }
            const inputData = new Float32Array(red.concat(green).concat(blue));
            return new ort.Tensor('float32', inputData, [1, 3, inputSize, inputSize]);
        }

        // YOLO输出解析
        function parseYOLOOutput(output, confThreshold, iouThreshold, inputSize) {
            const data = output.data;
            const boxes = [];
            for (let i = 0; i < data.length / 6; i++) {
                const conf = data[i * 6 + 4];
                if (conf < confThreshold) continue;
                const x = data[i * 6] * inputSize;
                const y = data[i * 6 + 1] * inputSize;
                const width = data[i * 6 + 2] * inputSize;
                const height = data[i * 6 + 3] * inputSize;
                boxes.push({ x, y, width, height, confidence: conf });
            }
            return boxes;
        }

        // 渲染检测结果
        function renderMarkers(detections) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            detections.forEach((det) => {
                ctx.beginPath();
                ctx.rect(det.x, det.y, det.width, det.height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'red';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fill();
                ctx.stroke();
            });
        }

        // 使用传统CV算法进行菌落检测（待补充）
        function analyzeCV() {
            showToast('⚙️ 使用传统CV算法进行菌落检测');
            // TODO: CV算法处理
        }
    </script>
</body>
</html>
