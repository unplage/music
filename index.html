<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤§é±¼åƒå°é±¼Â·çŠç‘šç¤å¥‡é‡</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Zcool+KuaiLe&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #006994 0%, #001e36 100%);
            font-family: 'Zcool KuaiLe', cursive, sans-serif;
            touch-action: none;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .interactive-btn {
            pointer-events: auto;
            transition: transform 0.1s, filter 0.2s;
            cursor: pointer;
            user-select: none;
        }
        .interactive-btn:active {
            transform: scale(0.95);
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 30, 54, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transition: opacity 0.3s;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        /* Skill cooldown animation */
        .cooldown-overlay {
            transition: height 0.1s linear;
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- In-Game HUD (Heads Up Display) -->
    <div id="gameUI" class="ui-layer hidden">
        <div class="flex justify-between items-start w-full">
            <div class="glass-panel px-6 py-3 text-white">
                <div class="text-sm opacity-80">å½“å‰å¾—åˆ†</div>
                <div class="text-3xl" id="scoreDisplay">0</div>
            </div>
            <button id="menuBtn" class="interactive-btn glass-panel p-3 text-white hover:bg-white/20">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
        </div>

        <!-- Skill Button -->
        <div class="flex justify-end items-end w-full pb-8 pr-4">
            <div class="relative">
                <div id="skillBtn" class="interactive-btn w-20 h-20 rounded-full glass-panel flex items-center justify-center text-white border-2 border-yellow-400/50 overflow-hidden relative">
                    <span class="text-2xl z-10">âš¡</span>
                    <div id="cooldownOverlay" class="absolute bottom-0 left-0 w-full bg-black/60 h-0 cooldown-overlay"></div>
                </div>
                <div class="text-center text-white text-xs mt-2 opacity-80">å†²åˆº (ç©ºæ ¼)</div>
            </div>
        </div>
    </div>

    <!-- Main Menu Screen -->
    <div id="mainMenu" class="menu-screen">
        <h1 class="text-6xl text-transparent bg-clip-text bg-gradient-to-b from-cyan-300 to-blue-500 mb-2 filter drop-shadow-lg">çŠç‘šç¤å¥‡é‡</h1>
        <p class="text-blue-200 mb-10 text-xl tracking-widest">BIG FISH EAT SMALL FISH</p>
        
        <div class="glass-panel p-8 flex flex-col gap-4 w-80 max-w-[90%]">
            <button onclick="game.selectMode('single')" class="interactive-btn bg-gradient-to-r from-cyan-500 to-blue-600 text-white py-4 rounded-xl text-xl shadow-lg hover:brightness-110">
                ğŸ® å•äººæ¨¡å¼
            </button>
            <button onclick="game.selectMode('team')" class="interactive-btn bg-gradient-to-r from-purple-500 to-indigo-600 text-white py-4 rounded-xl text-xl shadow-lg hover:brightness-110">
                ğŸ‘¥ ä¸‰äººAIç»„é˜Ÿ
            </button>
        </div>
    </div>

    <!-- Character Select Screen -->
    <div id="charSelect" class="menu-screen hidden">
        <h2 class="text-4xl text-white mb-8">é€‰æ‹©ä½ çš„é±¼ç±»</h2>
        <div class="flex gap-6 flex-wrap justify-center max-w-4xl">
            <!-- Card 1 -->
            <div onclick="game.startGame('speed')" class="interactive-btn glass-panel p-6 w-64 flex flex-col items-center hover:bg-white/20 group">
                <div class="w-24 h-24 bg-yellow-400 rounded-full mb-4 shadow-[0_0_20px_rgba(250,204,21,0.6)] flex items-center justify-center text-5xl group-hover:scale-110 transition-transform">âš¡</div>
                <h3 class="text-2xl text-yellow-300 mb-2">å‰‘é±¼çªåˆº</h3>
                <p class="text-blue-100 text-center text-sm">é€Ÿåº¦æå¿«ï¼Œä½“å‹å°å·§çµæ´»ï¼Œé€‚åˆå¿«é€Ÿçªè¢­ã€‚</p>
                <div class="mt-4 flex gap-2 text-xs text-white/70">
                    <span>âš¡âš¡âš¡</span> <span>ğŸ›¡ï¸</span>
                </div>
            </div>
            <!-- Card 2 -->
            <div onclick="game.startGame('balanced')" class="interactive-btn glass-panel p-6 w-64 flex flex-col items-center hover:bg-white/20 group border-blue-400 border-2">
                <div class="w-24 h-24 bg-blue-500 rounded-full mb-4 shadow-[0_0_20px_rgba(59,130,246,0.6)] flex items-center justify-center text-5xl group-hover:scale-110 transition-transform">ğŸ¬</div>
                <h3 class="text-2xl text-blue-300 mb-2">æµ·è±šæ¸¸ä¾ </h3>
                <p class="text-blue-100 text-center text-sm">å„é¡¹å±æ€§å‡è¡¡ï¼Œæ‹¥æœ‰ä¸é”™çš„å†²åˆºå†·å´æ¢å¤ã€‚</p>
                <div class="mt-4 flex gap-2 text-xs text-white/70">
                    <span>âš¡âš¡</span> <span>ğŸ›¡ï¸ğŸ›¡ï¸</span>
                </div>
            </div>
            <!-- Card 3 -->
            <div onclick="game.startGame('power')" class="interactive-btn glass-panel p-6 w-64 flex flex-col items-center hover:bg-white/20 group">
                <div class="w-24 h-24 bg-red-500 rounded-full mb-4 shadow-[0_0_20px_rgba(239,68,68,0.6)] flex items-center justify-center text-5xl group-hover:scale-110 transition-transform">ğŸ¦ˆ</div>
                <h3 class="text-2xl text-red-300 mb-2">æ·±æµ·å·¨é²¨</h3>
                <p class="text-blue-100 text-center text-sm">åˆå§‹ä½“å‹å·¨å¤§ï¼Œé€Ÿåº¦è¾ƒæ…¢ï¼Œä½†å¯ä»¥åå™¬æ›´å¤šé±¼ç±»ã€‚</p>
                <div class="mt-4 flex gap-2 text-xs text-white/70">
                    <span>âš¡</span> <span>ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸</span>
                </div>
            </div>
        </div>
        <button onclick="game.showScreen('mainMenu')" class="mt-10 text-white/60 hover:text-white underline">è¿”å›ä¸Šçº§</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOver" class="menu-screen hidden">
        <h2 class="text-5xl text-white mb-4">æ¸¸æˆç»“æŸ</h2>
        <div class="glass-panel px-12 py-8 flex flex-col items-center mb-8">
            <span class="text-blue-200 text-lg">æœ€ç»ˆå¾—åˆ†</span>
            <span id="finalScore" class="text-6xl text-yellow-400 font-bold my-2">0</span>
        </div>
        <button onclick="game.resetGame()" class="interactive-btn bg-gradient-to-r from-green-500 to-emerald-600 text-white py-3 px-12 rounded-full text-2xl shadow-lg hover:brightness-110 animate-bounce">
            é‡æ–°å¼€å§‹
        </button>
    </div>

    <script>
        /**
         * Game Logic
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const screens = {
            main: document.getElementById('mainMenu'),
            char: document.getElementById('charSelect'),
            game: document.getElementById('gameUI'),
            over: document.getElementById('gameOver')
        };
        const scoreEl = document.getElementById('scoreDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const skillBtn = document.getElementById('skillBtn');
        const cooldownOverlay = document.getElementById('cooldownOverlay');
        const menuBtn = document.getElementById('menuBtn');

        // Game State
        let animationId;
        let lastTime = 0;
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;

        // Configuration
        const CONFIG = {
            fishTypes: {
                speed: { color: '#FACC15', radius: 8, speed: 5, cd: 120, name: 'å‰‘é±¼' },
                balanced: { color: '#3B82F6', radius: 12, speed: 4, cd: 90, name: 'æµ·è±š' },
                power: { color: '#EF4444', radius: 18, speed: 3, cd: 150, name: 'å·¨é²¨' }
            }
        };

        class Game {
            constructor() {
                this.state = 'MENU'; // MENU, PLAYING, PAUSED, GAMEOVER
                this.mode = 'single'; // single, team
                this.score = 0;
                this.player = null;
                this.teammates = [];
                this.enemies = [];
                this.particles = [];
                this.bubbles = [];
                this.frameCount = 0;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                window.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') this.activateSkill();
                });
                
                skillBtn.addEventListener('click', () => this.activateSkill());
                menuBtn.addEventListener('click', () => {
                    if (this.state === 'PLAYING') {
                        this.state = 'PAUSED';
                        this.showScreen('main');
                    }
                });

                // Initial render for background
                this.loop(0);
            }

            resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            showScreen(screenName) {
                Object.values(screens).forEach(el => el.classList.add('hidden'));
                if (screenName === 'main') screens.main.classList.remove('hidden');
                if (screenName === 'char') screens.char.classList.remove('hidden');
                if (screenName === 'game') screens.game.classList.remove('hidden');
                if (screenName === 'over') screens.over.classList.remove('hidden');
            }

            selectMode(mode) {
                this.mode = mode;
                this.showScreen('char');
            }

            startGame(type) {
                this.state = 'PLAYING';
                this.score = 0;
                this.showScreen('game');
                scoreEl.innerText = '0';
                
                // Init Player
                const stats = CONFIG.fishTypes[type];
                this.player = new Fish(canvas.width/2, canvas.height/2, stats.radius, stats.color, stats.speed, true, stats.cd);
                
                // Init Teammates if team mode
                this.teammates = [];
                if (this.mode === 'team') {
                    // Create 2 smaller allies
                    this.teammates.push(new Fish(canvas.width/2 - 50, canvas.height/2, 10, '#A78BFA', stats.speed * 0.9, false, 0));
                    this.teammates.push(new Fish(canvas.width/2 + 50, canvas.height/2, 10, '#A78BFA', stats.speed * 0.9, false, 0));
                }

                this.enemies = [];
                this.particles = [];
                // Init some bubbles
                this.bubbles = Array.from({length: 20}, () => new Bubble());
                
                // Reset loops
                if (animationId) cancelAnimationFrame(animationId);
                this.loop(0);
            }

            resetGame() {
                this.showScreen('main');
                this.state = 'MENU';
            }

            activateSkill() {
                if (this.state === 'PLAYING' && this.player && this.player.canDash) {
                    this.player.dash();
                }
            }

            spawnEnemy() {
                // Difficulty scaling
                const maxEnemies = 10 + Math.floor(this.score / 500);
                if (this.enemies.length >= maxEnemies) return;

                const edge = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
                let x, y, vx, vy;
                const speed = 1 + Math.random() * 2 + (this.score / 1000); // Get faster over time
                const radius = 5 + Math.random() * 25; // Random sizes

                if (edge === 0) { x = Math.random() * canvas.width; y = -50; vy = speed; vx = (Math.random() - 0.5) * speed; }
                else if (edge === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; vx = -speed; vy = (Math.random() - 0.5) * speed; }
                else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; vy = -speed; vx = (Math.random() - 0.5) * speed; }
                else { x = -50; y = Math.random() * canvas.height; vx = speed; vy = (Math.random() - 0.5) * speed; }

                // Ensure they move into screen
                this.enemies.push(new Fish(x, y, radius, this.getRandomColor(), speed, false, 0, vx, vy));
            }

            getRandomColor() {
                const colors = ['#F87171', '#FB923C', '#F472B6', '#34D399', '#A78BFA'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            createExplosion(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            checkCollisions() {
                // 1. Player vs Enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                    
                    if (dist < this.player.radius + enemy.radius) {
                        if (this.player.radius > enemy.radius * 1.1) {
                            // Eat
                            this.score += Math.floor(enemy.radius * 10);
                            scoreEl.innerText = this.score;
                            this.createExplosion(enemy.x, enemy.y, enemy.color);
                            this.player.grow(enemy.radius * 0.05);
                            this.enemies.splice(i, 1);
                        } else if (enemy.radius > this.player.radius * 1.1) {
                            // Die
                            this.gameOver();
                            return;
                        }
                    }
                }

                // 2. Teammates vs Enemies (AI Logic)
                this.teammates.forEach(mate => {
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        const dist = Math.hypot(mate.x - enemy.x, mate.y - enemy.y);
                        if (dist < mate.radius + enemy.radius && mate.radius > enemy.radius) {
                            this.score += Math.floor(enemy.radius * 5); // Less score for AI kills
                            scoreEl.innerText = this.score;
                            mate.grow(enemy.radius * 0.02);
                            this.enemies.splice(i, 1);
                            break; 
                        }
                    }
                });
            }

            gameOver() {
                this.state = 'GAMEOVER';
                finalScoreEl.innerText = this.score;
                this.showScreen('over');
            }

            update(dt) {
                if (this.state !== 'PLAYING') return;

                this.frameCount++;
                if (this.frameCount % 60 === 0) this.spawnEnemy();

                // Update Bubbles
                this.bubbles.forEach(b => b.update());
                
                // Update Player
                this.player.update(mouseX, mouseY);

                // Update Teammates (Simple AI: Follow Player + Separation)
                this.teammates.forEach((mate, index) => {
                    // Target position around player
                    const angle = (index + 1) * (Math.PI * 2 / 3); // Spread them out
                    const tx = this.player.x + Math.cos(angle + this.frameCount * 0.01) * 60;
                    const ty = this.player.y + Math.sin(angle + this.frameCount * 0.01) * 60;
                    mate.update(tx, ty, true); // true = is AI target
                });

                // Update Enemies
                this.enemies.forEach(e => e.update(null, null));
                // Remove off-screen enemies
                this.enemies = this.enemies.filter(e => 
                    e.x > -100 && e.x < canvas.width + 100 && 
                    e.y > -100 && e.y < canvas.height + 100
                );

                // Update Particles
                this.particles = this.particles.filter(p => p.life > 0);
                this.particles.forEach(p => p.update());

                // Cooldown UI
                if (this.player) {
                    const cdPercent = (this.player.dashCooldown / this.player.maxDashCooldown) * 100;
                    cooldownOverlay.style.height = `${cdPercent}%`;
                    if (this.player.canDash) {
                        skillBtn.style.borderColor = '#FACC15';
                        skillBtn.style.boxShadow = '0 0 15px #FACC15';
                    } else {
                        skillBtn.style.borderColor = 'rgba(255,255,255,0.3)';
                        skillBtn.style.boxShadow = 'none';
                    }
                }

                this.checkCollisions();
            }

            draw() {
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Background Decor
                this.drawBackground();

                if (this.state === 'PLAYING' || this.state === 'PAUSED') {
                    // Draw Bubbles
                    this.bubbles.forEach(b => b.draw(ctx));

                    // Draw Teammates
                    this.teammates.forEach(mate => mate.draw(ctx, 'ğŸŸ'));

                    // Draw Enemies
                    this.enemies.forEach(e => e.draw(ctx, 'ğŸ '));

                    // Draw Player
                    if (this.player) this.player.draw(ctx, 'ğŸ¬');

                    // Draw Particles
                    this.particles.forEach(p => p.draw(ctx));
                }
            }

            drawBackground() {
                // Draw Coral Reefs (Static shapes at bottom)
                ctx.fillStyle = 'rgba(0, 20, 40, 0.4)';
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                for(let i=0; i<=canvas.width; i+=50) {
                    ctx.lineTo(i, canvas.height - 50 - Math.sin(i * 0.01) * 30 - Math.random()*10);
                }
                ctx.lineTo(canvas.width, canvas.height);
                ctx.fill();
            }

            loop(timestamp) {
                const dt = timestamp - lastTime;
                lastTime = timestamp;

                this.update(dt);
                this.draw();

                animationId = requestAnimationFrame((t) => this.loop(t));
            }
        }

        /**
         * Entities
         */
        class Fish {
            constructor(x, y, radius, color, speed, isPlayer, dashCDMax, vx, vy) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.speed = speed;
                this.isPlayer = isPlayer;
                this.angle = 0;
                
                // Physics
                this.vx = vx || 0;
                this.vy = vy || 0;

                // Dash Skill
                this.maxDashCooldown = dashCDMax;
                this.dashCooldown = 0;
                this.isDashing = false;
                this.dashTime = 0;
            }

            get canDash() {
                return this.dashCooldown <= 0;
            }

            dash() {
                this.isDashing = true;
                this.dashTime = 15; // Frames
                this.dashCooldown = this.maxDashCooldown;
                // Burst of speed handled in update
            }

            grow(amount) {
                this.radius = Math.min(this.radius + amount, 100); // Cap size
            }

            update(targetX, targetY, isAI = false) {
                // Cooldowns
                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.dashTime > 0) this.dashTime--;
                else this.isDashing = false;

                // Movement Logic
                if (this.isPlayer || isAI) {
                    let dx, dy;
                    
                    if (this.isPlayer) {
                        dx = targetX - this.x;
                        dy = targetY - this.y;
                    } else {
                        // AI Follow logic
                        dx = targetX - this.x;
                        dy = targetY - this.y;
                    }

                    const dist = Math.hypot(dx, dy);
                    
                    // Only move if far enough (prevents jitter)
                    if (dist > 5) {
                        const currentSpeed = this.isDashing ? this.speed * 3 : this.speed;
                        const moveX = (dx / dist) * currentSpeed;
                        const moveY = (dy / dist) * currentSpeed;

                        // Smooth turning
                        this.vx += (moveX - this.vx) * 0.1;
                        this.vy += (moveY - this.vy) * 0.1;
                        
                        this.angle = Math.atan2(this.vy, this.vx);
                    }
                } else {
                    // Enemy linear movement (could add wobble here)
                    this.x += this.vx;
                    this.y += this.vy;
                    this.angle = Math.atan2(this.vy, this.vx);
                }

                if (this.isPlayer || isAI) {
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Boundaries
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                }
            }

            draw(ctx, emoji) {
                ctx.save();
                ctx.translate(this.x, this.y);
                // Flip if moving left
                if (Math.abs(this.angle) > Math.PI / 2) {
                    ctx.scale(1, -1);
                    ctx.rotate(-this.angle);
                } else {
                    ctx.rotate(this.angle);
                }

                // Glow if dashing
                if (this.isDashing) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FFF';
                }

                // Draw Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.5, this.radius, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw Tail
                ctx.beginPath();
                ctx.moveTo(-this.radius, 0);
                ctx.lineTo(-this.radius * 2.2, -this.radius * 0.8);
                ctx.lineTo(-this.radius * 2.2, this.radius * 0.8);
                ctx.fill();

                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.radius * 0.8, -this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.radius * 0.9, -this.radius * 0.3, this.radius * 0.15, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Bubble {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height; // Start randomly
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height + 10;
                this.size = Math.random() * 5 + 2;
                this.speed = Math.random() * 1 + 0.5;
                this.alpha = Math.random() * 0.5 + 0.1;
            }
            update() {
                this.y -= this.speed;
                if (this.y < -10) this.reset();
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // Start Game Instance
        const game = new Game();

    </script>
</body>
</html>
