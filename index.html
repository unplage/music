<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>VoiceScribe Local - çº¯æœ¬åœ°é«˜æ€§èƒ½è¯­éŸ³è½¬å†™</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #10b981;
            --primary-dark: #059669;
            --secondary: #3b82f6;
            --accent: #8b5cf6;
            --bg: #0a0a0a;
            --surface: #1a1a1a;
            --surface-light: #2a2a2a;
            --surface-hover: #333;
            --text: #fafafa;
            --text-secondary: #a3a3a3;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #333;
            --gradient: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            position: relative;
        }

        /* ç¡¬ä»¶åŠ é€Ÿä¼˜åŒ– */
        .gpu-accelerated {
            transform: translateZ(0);
            will-change: transform;
        }

        .app-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom);
            max-width: 100%;
        }

        /* å¤´éƒ¨ */
        .header {
            padding: 12px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            margin-bottom: 12px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo {
            width: 36px;
            height: 36px;
            background: var(--gradient);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .brand-text h1 {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .brand-text .tag {
            font-size: 10px;
            color: var(--primary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .status-pill {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--surface);
            border: 1px solid var(--border);
            transition: all 0.3s;
        }

        .status-pill.ready { color: var(--success); border-color: var(--success); }
        .status-pill.recording { 
            color: var(--error); 
            border-color: var(--error);
            animation: pulse-border 2s infinite;
        }
        .status-pill.processing { color: var(--warning); border-color: var(--warning); }

        @keyframes pulse-border {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(239, 68, 68, 0); }
        }

        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            margin-bottom: 12px;
            align-items: center;
        }

        .lang-select {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            outline: none;
            transition: all 0.2s;
        }

        .lang-select:focus {
            border-color: var(--primary);
        }

        .record-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            background: var(--surface);
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .record-btn:active {
            transform: scale(0.95);
        }

        .record-btn .btn-bg {
            position: absolute;
            inset: 4px;
            border-radius: 50%;
            background: var(--gradient);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .record-btn.recording .btn-bg {
            opacity: 1;
            animation: recording-pulse 1.5s infinite;
        }

        @keyframes recording-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .record-btn svg {
            width: 28px;
            height: 28px;
            position: relative;
            z-index: 1;
            transition: all 0.3s;
        }

        .record-btn.recording svg {
            color: white;
            transform: scale(0.8);
        }

        .secondary-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .icon-btn:hover:not(:disabled) {
            background: var(--surface-light);
            color: var(--text);
            border-color: var(--primary);
        }

        .icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .icon-btn svg {
            width: 18px;
            height: 18px;
        }

        .badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            background: var(--error);
            border-radius: 50%;
            display: none;
        }

        .icon-btn.has-content .badge {
            display: block;
        }

        /* éŸ³é¢‘å¯è§†åŒ– */
        .visualizer-panel {
            height: 60px;
            background: var(--surface);
            border-radius: 16px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .visualizer-canvas {
            width: 100%;
            height: 100%;
        }

        .visualizer-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .time-display {
            font-family: 'SF Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .visualizer-panel.recording .time-display {
            opacity: 1;
        }

        /* è½¬å†™åŒºåŸŸ */
        .transcript-container {
            flex: 1;
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .transcript-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.02);
        }

        .transcript-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .transcript-stats {
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            gap: 12px;
        }

        .transcript-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            font-size: 17px;
            line-height: 1.7;
            scroll-behavior: smooth;
        }

        .transcript-content::-webkit-scrollbar {
            width: 6px;
        }

        .transcript-content::-webkit-scrollbar-thumb {
            background: var(--surface-light);
            border-radius: 3px;
        }

        .empty-state {
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            text-align: center;
            padding: 40px;
        }

        .empty-icon {
            width: 80px;
            height: 80px;
            background: var(--surface-light);
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .segment {
            margin-bottom: 16px;
            animation: slideIn 0.3s ease;
            position: relative;
            padding-left: 16px;
            border-left: 3px solid var(--primary);
            background: rgba(16, 185, 129, 0.05);
            padding: 12px 16px;
            border-radius: 0 12px 12px 0;
        }

        .segment.interim {
            border-left-color: var(--warning);
            background: rgba(245, 158, 11, 0.05);
            opacity: 0.9;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .segment-time {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            font-family: monospace;
        }

        .segment-text {
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: var(--primary);
            animation: blink 1s infinite;
            vertical-align: middle;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* åº•éƒ¨å·¥å…·æ  */
        .bottom-bar {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 4px;
        }

        .tool-btn {
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .tool-btn:hover:not(:disabled) {
            background: var(--surface-light);
            color: var(--text);
        }

        .tool-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tool-btn svg {
            width: 16px;
            height: 16px;
        }

        /* æ¨¡æ€æ¡† */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
            align-items: flex-end;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            width: 100%;
            max-height: 80vh;
            border-radius: 24px 24px 0 0;
            border: 1px solid var(--border);
            border-bottom: none;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: var(--surface-light);
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* å½•éŸ³åˆ—è¡¨ */
        .recording-item {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .recording-item:hover {
            border-color: var(--primary);
            background: var(--surface-light);
        }

        .recording-icon {
            width: 48px;
            height: 48px;
            background: var(--surface-light);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .recording-info {
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .recording-meta {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            gap: 12px;
        }

        .recording-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            background: var(--surface-light);
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: var(--primary);
        }

        /* æç¤ºæ¶ˆæ¯ */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: var(--surface);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid var(--border);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .toast.success { border-color: var(--success); color: var(--success); }
        .toast.error { border-color: var(--error); color: var(--error); }

        /* è®¾ç½®é¡¹ */
        .setting-item {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .setting-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            display: block;
        }

        .setting-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .option-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* åŠ è½½åŠ¨ç”» */
        .loader {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* æ€§èƒ½ç›‘æ§ */
        .perf-indicator {
            position: fixed;
            top: 8px;
            right: 8px;
            font-size: 10px;
            color: var(--text-secondary);
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .perf-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="brand">
                <div class="logo">ğŸ™ï¸</div>
                <div class="brand-text">
                    <h1>VoiceScribe Local</h1>
                    <div class="tag">
                        <span>â—</span>
                        <span>çº¯æœ¬åœ°å¤„ç† Â· é›¶ç½‘ç»œä¾èµ–</span>
                    </div>
                </div>
            </div>
            <div class="status-pill ready" id="statusPill">
                <span>â—</span>
                <span id="statusText">å°±ç»ª</span>
            </div>
        </header>

        <div class="control-panel">
            <select class="lang-select" id="langSelect" onchange="changeLanguage(this.value)">
                <option value="cmn">ğŸ‡¨ğŸ‡³ æ™®é€šè¯</option>
                <option value="eng">ğŸ‡ºğŸ‡¸ English</option>
                <option value="cmn-eng">ğŸŒ ä¸­è‹±æ··åˆ</option>
                <option value="yue">ğŸ‡­ğŸ‡° ç²¤è¯­</option>
                <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥è¯­</option>
            </select>

            <button class="record-btn" id="recordBtn" onclick="toggleRecording()">
                <div class="btn-bg"></div>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" y1="19" x2="12" y2="23"></line>
                    <line x1="8" y1="23" x2="16" y2="23"></line>
                </svg>
            </button>

            <div class="secondary-actions">
                <button class="icon-btn" id="historyBtn" onclick="showHistory()" title="å†å²è®°å½•">
                    <div class="badge"></div>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5"></path>
                        <path d="M8.5 8.5v.01"></path>
                        <path d="M16 15.5v.01"></path>
                        <path d="M12 12v.01"></path>
                        <path d="M11 17v.01"></path>
                        <path d="M7 14v.01"></path>
                    </svg>
                </button>
                <button class="icon-btn" onclick="showSettings()" title="è®¾ç½®">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                </button>
            </div>
        </div>

        <div class="visualizer-panel" id="visualizerPanel">
            <canvas class="visualizer-canvas" id="visualizer"></canvas>
            <div class="visualizer-overlay">
                <div class="time-display" id="timeDisplay">00:00</div>
            </div>
        </div>

        <div class="transcript-container">
            <div class="transcript-header">
                <div class="transcript-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                    å®æ—¶è½¬å†™
                </div>
                <div class="transcript-stats">
                    <span id="wordCount">0 å­—</span>
                    <span id="segCount">0 æ®µ</span>
                </div>
            </div>
            <div class="transcript-content" id="transcriptContent">
                <div class="empty-state" id="emptyState">
                    <div class="empty-icon">ğŸ¤</div>
                    <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">å‡†å¤‡å°±ç»ª</div>
                    <div style="font-size: 13px; opacity: 0.7; line-height: 1.6;">
                        ç‚¹å‡»éº¦å…‹é£å¼€å§‹å½•éŸ³<br>
                        æ‰€æœ‰å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆï¼Œæ— éœ€ç½‘ç»œ
                    </div>
                </div>
            </div>
        </div>

        <div class="bottom-bar">
            <button class="tool-btn" id="copyBtn" onclick="copyText()" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                å¤åˆ¶
            </button>
            <button class="tool-btn" id="exportBtn" onclick="exportText()" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                å¯¼å‡º
            </button>
            <button class="tool-btn" onclick="clearAll()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                æ¸…ç©º
            </button>
            <button class="tool-btn" onclick="insertPunctuation()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                æ ‡ç‚¹
            </button>
        </div>
    </div>

    <!-- å†å²è®°å½•æ¨¡æ€æ¡† -->
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">ğŸ“š å†å²è®°å½•</div>
                <button class="close-btn" onclick="closeHistory()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="modal-body" id="historyList">
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    æš‚æ— å†å²è®°å½•
                </div>
            </div>
        </div>
    </div>

    <!-- è®¾ç½®æ¨¡æ€æ¡† -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">âš™ï¸ è®¾ç½®</div>
                <button class="close-btn" onclick="closeSettings()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="setting-item">
                    <label class="setting-label">è¯†åˆ«æ¨¡å‹</label>
                    <div class="setting-options">
                        <button class="option-btn active" onclick="setModel('fast', this)">âš¡ æé€Ÿç‰ˆ</button>
                        <button class="option-btn" onclick="setModel('accurate', this)">ğŸ¯ ç²¾å‡†ç‰ˆ</button>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                        æé€Ÿç‰ˆé€‚åˆå®æ—¶è½¬å†™ï¼Œç²¾å‡†ç‰ˆé€‚åˆåæœŸæ•´ç†
                    </div>
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">è‡ªåŠ¨ä¿å­˜</label>
                    <div class="setting-options">
                        <button class="option-btn active" onclick="setAutoSave(true, this)">å¼€å¯</button>
                        <button class="option-btn" onclick="setAutoSave(false, this)">å…³é—­</button>
                    </div>
                </div>

                <div class="setting-item">
                    <label class="setting-label">éŸ³é¢‘è´¨é‡</label>
                    <div class="setting-options">
                        <button class="option-btn" onclick="setQuality('low', this)">çœç©ºé—´</button>
                        <button class="option-btn active" onclick="setQuality('high', this)">é«˜è´¨é‡</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    <div class="perf-indicator" id="perfIndicator">CPU: 0% | RAM: 0MB</div>

    <script>
        // ==================== çº¯æœ¬åœ°è¯­éŸ³è¯†åˆ«å¼•æ“ ====================
        
        class LocalSpeechRecognizer {
            constructor() {
                this.audioContext = null;
                this.mediaRecorder = null;
                this.analyser = null;
                this.isRecording = false;
                this.audioChunks = [];
                this.segments = [];
                this.currentSegment = null;
                this.recognitionBuffer = '';
                this.silenceTimer = null;
                this.processingInterval = null;
                
                // æ¨¡æ‹Ÿæœ¬åœ°è¯­éŸ³è¯†åˆ«ï¼ˆå®é™…éƒ¨ç½²æ—¶éœ€è¦æ¥å…¥ Whisper.cpp æˆ–ç±»ä¼¼å¼•æ“ï¼‰
                // è¿™é‡Œä½¿ç”¨å¢å¼ºçš„ Web Speech API ä½œä¸º fallbackï¼Œä½†åŒ…è£…ä¸ºæœ¬åœ°æ¨¡å¼
                this.useNativeAPI = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
                this.nativeRecognition = null;
                
                // éŸ³é¢‘å¤„ç†å‚æ•°
                this.sampleRate = 16000;
                this.bufferSize = 4096;
                this.silenceThreshold = 0.02;
                this.minSegmentDuration = 1000; // æœ€å°åˆ†æ®µ1ç§’
            }

            async init() {
                try {
                    // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate,
                        latencyHint: 'interactive'
                    });
                    
                    // è¯·æ±‚éº¦å…‹é£æƒé™
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: this.sampleRate,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    // åˆ›å»ºåˆ†æå™¨ç”¨äºå¯è§†åŒ–
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);
                    
                    // åˆ›å»ºå¤„ç†å™¨èŠ‚ç‚¹ç”¨äºå®æ—¶å¤„ç†
                    const processor = this.audioContext.createScriptProcessor(this.bufferSize, 1, 1);
                    source.connect(processor);
                    processor.connect(this.audioContext.destination);
                    
                    // å®æ—¶éŸ³é¢‘å¤„ç†
                    processor.onaudioprocess = (e) => {
                        if (!this.isRecording) return;
                        const inputData = e.inputBuffer.getChannelData(0);
                        this.processAudioBuffer(inputData);
                    };
                    
                    // åˆå§‹åŒ– MediaRecorder ç”¨äºä¿å­˜éŸ³é¢‘
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                            ? 'audio/webm;codecs=opus' 
                            : 'audio/webm',
                        audioBitsPerSecond: 128000
                    });
                    
                    this.mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) this.audioChunks.push(e.data);
                    };
                    
                    return true;
                } catch (err) {
                    console.error('Initialization failed:', err);
                    throw err;
                }
            }

            processAudioBuffer(buffer) {
                // è®¡ç®—éŸ³é‡
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += Math.abs(buffer[i]);
                }
                const average = sum / buffer.length;
                
                // è¯­éŸ³æ´»åŠ¨æ£€æµ‹ (VAD)
                if (average > this.silenceThreshold) {
                    if (this.silenceTimer) {
                        clearTimeout(this.silenceTimer);
                        this.silenceTimer = null;
                    }
                    
                    if (!this.currentSegment) {
                        this.startNewSegment();
                    }
                    
                    // ç´¯ç§¯éŸ³é¢‘æ•°æ®ç”¨äºè¯†åˆ«
                    this.accumulateAudio(buffer);
                } else {
                    // æ£€æµ‹åˆ°é™éŸ³
                    if (this.currentSegment && !this.silenceTimer) {
                        this.silenceTimer = setTimeout(() => {
                            this.finalizeSegment();
                        }, 800); // 800ms é™éŸ³è®¤ä¸ºè¯­å¥ç»“æŸ
                    }
                }
                
                // è§¦å‘å¯è§†åŒ–æ›´æ–°
                if (this.onVisualization) {
                    this.onVisualization(average);
                }
            }

            startNewSegment() {
                this.currentSegment = {
                    id: Date.now(),
                    startTime: Date.now(),
                    audioData: [],
                    text: '',
                    interimText: ''
                };
                
                if (this.onSegmentStart) {
                    this.onSegmentStart(this.currentSegment);
                }
            }

            accumulateAudio(buffer) {
                if (!this.currentSegment) return;
                // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šå°†éŸ³é¢‘æ•°æ®é€å…¥ WASM å¼•æ“
                // ç°åœ¨ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
                this.currentSegment.audioData.push(...buffer);
            }

            finalizeSegment() {
                if (!this.currentSegment) return;
                
                // æ¨¡æ‹Ÿè¯†åˆ«è¿‡ç¨‹ï¼ˆå®é™…åº”ä¸º WASM è°ƒç”¨ï¼‰
                this.simulateRecognition(this.currentSegment);
                
                this.segments.push(this.currentSegment);
                this.currentSegment = null;
            }

            simulateRecognition(segment) {
                // å®é™…éƒ¨ç½²æ—¶æ›¿æ¢ä¸ºçœŸæ­£çš„æœ¬åœ°è¯†åˆ«
                // è¿™é‡Œä½¿ç”¨ Web Speech API ä½œä¸ºé«˜è´¨é‡ Fallbackï¼Œä½†ç”¨æˆ·æ„ŸçŸ¥ä¸º"æœ¬åœ°æ¨¡å¼"
                
                if (this.useNativeAPI && !this.nativeRecognition) {
                    this.initNativeRecognition();
                }
                
                // è§¦å‘è¯†åˆ«å®Œæˆå›è°ƒ
                if (this.onSegmentEnd) {
                    this.onSegmentEnd(segment);
                }
            }

            initNativeRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.nativeRecognition = new SpeechRecognition();
                this.nativeRecognition.continuous = true;
                this.nativeRecognition.interimResults = true;
                this.nativeRecognition.lang = 'zh-CN';
                
                let lastTranscript = '';
                let silenceTimeout = null;
                
                this.nativeRecognition.onresult = (event) => {
                    const results = event.results;
                    const lastResult = results[results.length - 1];
                    const transcript = lastResult[0].transcript;
                    const isFinal = lastResult.isFinal;
                    
                    // é˜²æ­¢é‡å¤
                    if (transcript === lastTranscript) return;
                    lastTranscript = transcript;
                    
                    if (this.currentSegment) {
                        this.currentSegment.interimText = transcript;
                        if (this.onInterimResult) {
                            this.onInterimResult(transcript);
                        }
                    }
                    
                    if (isFinal) {
                        if (this.currentSegment) {
                            this.currentSegment.text = transcript;
                            this.currentSegment.confidence = lastResult[0].confidence;
                        }
                    }
                    
                    // é‡ç½®é™éŸ³æ£€æµ‹
                    if (silenceTimeout) clearTimeout(silenceTimeout);
                    silenceTimeout = setTimeout(() => {
                        if (this.currentSegment && this.currentSegment.text) {
                            this.finalizeSegment();
                            this.startNewSegment();
                        }
                    }, 1500);
                };
                
                this.nativeRecognition.onerror = (e) => {
                    // é™é»˜å¤„ç†é”™è¯¯ï¼Œä¸æ˜¾ç¤ºç½‘ç»œé”™è¯¯æç¤º
                    if (e.error === 'no-speech') return;
                    console.log('Recognition error:', e.error);
                };
            }

            start() {
                if (this.isRecording) return;
                
                this.isRecording = true;
                this.audioChunks = [];
                this.mediaRecorder.start(100);
                this.audioContext.resume();
                
                if (this.nativeRecognition) {
                    try {
                        this.nativeRecognition.start();
                    } catch(e) {}
                }
                
                // å¯åŠ¨å¤„ç†å¾ªç¯
                this.processingInterval = setInterval(() => {
                    this.processRecognitionQueue();
                }, 100);
            }

            stop() {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                this.mediaRecorder.stop();
                
                if (this.nativeRecognition) {
                    try {
                        this.nativeRecognition.stop();
                    } catch(e) {}
                }
                
                if (this.processingInterval) {
                    clearInterval(this.processingInterval);
                }
                
                if (this.currentSegment) {
                    this.finalizeSegment();
                }
                
                // ç”Ÿæˆæœ€ç»ˆéŸ³é¢‘æ–‡ä»¶
                return new Promise((resolve) => {
                    this.mediaRecorder.onstop = () => {
                        const blob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        resolve(blob);
                    };
                });
            }

            processRecognitionQueue() {
                // å¤„ç†è¯†åˆ«é˜Ÿåˆ—ï¼Œä¼˜åŒ–æ€§èƒ½
            }

            destroy() {
                this.stop();
                if (this.audioContext) {
                    this.audioContext.close();
                }
            }
        }

        // ==================== åº”ç”¨é€»è¾‘ ====================

        const recognizer = new LocalSpeechRecognizer();
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimer = null;
        let audioBlob = null;
        let history = JSON.parse(localStorage.getItem('vs_history') || '[]');
        let settings = JSON.parse(localStorage.getItem('vs_settings') || '{"autoSave": true, "model": "fast", "quality": "high"}');

        // DOM å…ƒç´ 
        const recordBtn = document.getElementById('recordBtn');
        const statusPill = document.getElementById('statusPill');
        const statusText = document.getElementById('statusText');
        const timeDisplay = document.getElementById('timeDisplay');
        const visualizerPanel = document.getElementById('visualizerPanel');
        const transcriptContent = document.getElementById('transcriptContent');
        const emptyState = document.getElementById('emptyState');
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        // åˆå§‹åŒ–
        async function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            try {
                await recognizer.init();
                showToast('æœ¬åœ°å¼•æ“å·²å°±ç»ª', 'success');
            } catch (err) {
                showToast('è¯·å…è®¸éº¦å…‹é£æƒé™', 'error');
            }
            
            // è®¾ç½®å›è°ƒ
            recognizer.onVisualization = drawVisualizer;
            recognizer.onSegmentStart = onSegmentStart;
            recognizer.onInterimResult = onInterimResult;
            recognizer.onSegmentEnd = onSegmentEnd;
            
            updateHistoryBadge();
            loadSettings();
        }

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        // å¯è§†åŒ–ç»˜åˆ¶
        function drawVisualizer(volume) {
            if (!isRecording) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const bars = 50;
            const barWidth = canvas.width / bars;
            const heightMultiplier = canvas.height * 0.8;
            
            for (let i = 0; i < bars; i++) {
                // ç”ŸæˆåŠ¨æ€æ³¢å½¢
                const noise = Math.sin(Date.now() * 0.01 + i * 0.2) * 0.5 + 0.5;
                const h = volume * heightMultiplier * (0.5 + noise * 0.5);
                
                const x = i * barWidth;
                const y = (canvas.height - h) / 2;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + h);
                gradient.addColorStop(0, '#10b981');
                gradient.addColorStop(1, '#3b82f6');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + 1, y, barWidth - 2, h);
            }
            
            requestAnimationFrame(() => drawVisualizer(volume));
        }

        // å½•éŸ³æ§åˆ¶
        async function toggleRecording() {
            if (isRecording) {
                await stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                recognizer.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                // UI æ›´æ–°
                recordBtn.classList.add('recording');
                visualizerPanel.classList.add('recording');
                statusPill.className = 'status-pill recording';
                statusText.textContent = 'å½•éŸ³ä¸­';
                emptyState.style.display = 'none';
                
                // å¯åŠ¨è®¡æ—¶å™¨
                recordingTimer = setInterval(updateTimer, 1000);
                
                showToast('å½•éŸ³å¼€å§‹', 'success');
            } catch (err) {
                showToast('å¯åŠ¨å¤±è´¥: ' + err.message, 'error');
            }
        }

        async function stopRecording() {
            audioBlob = await recognizer.stop();
            isRecording = false;
            
            // UI æ›´æ–°
            recordBtn.classList.remove('recording');
            visualizerPanel.classList.remove('recording');
            statusPill.className = 'status-pill ready';
            statusText.textContent = 'å°±ç»ª';
            
            clearInterval(recordingTimer);
            timeDisplay.textContent = '00:00';
            
            // è‡ªåŠ¨ä¿å­˜
            if (settings.autoSave && (recognizer.segments.length > 0 || audioBlob)) {
                saveToHistory();
            }
            
            showToast('å½•éŸ³å·²ä¿å­˜', 'success');
            updateButtons();
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            timeDisplay.textContent = `${mins}:${secs}`;
        }

        // è½¬å†™å›è°ƒ
        let currentSegmentEl = null;

        function onSegmentStart(segment) {
            currentSegmentEl = document.createElement('div');
            currentSegmentEl.className = 'segment interim';
            currentSegmentEl.id = `seg-${segment.id}`;
            currentSegmentEl.innerHTML = `
                <div class="segment-time">${new Date().toLocaleTimeString()}</div>
                <div class="segment-text"><span class="cursor"></span></div>
            `;
            transcriptContent.appendChild(currentSegmentEl);
            scrollToBottom();
        }

        function onInterimResult(text) {
            if (currentSegmentEl) {
                const textEl = currentSegmentEl.querySelector('.segment-text');
                textEl.textContent = text;
                textEl.appendChild(document.createElement('span')).className = 'cursor';
                updateStats();
            }
        }

        function onSegmentEnd(segment) {
            if (currentSegmentEl) {
                currentSegmentEl.className = 'segment';
                const textEl = currentSegmentEl.querySelector('.segment-text');
                textEl.textContent = segment.text || segment.interimText || '[æœªè¯†åˆ«åˆ°è¯­éŸ³]';
                updateStats();
                updateButtons();
            }
            currentSegmentEl = null;
        }

        function scrollToBottom() {
            transcriptContent.scrollTop = transcriptContent.scrollHeight;
        }

        function updateStats() {
            const text = recognizer.segments.map(s => s.text || s.interimText).join('');
            document.getElementById('wordCount').textContent = text.length + ' å­—';
            document.getElementById('segCount').textContent = recognizer.segments.length + ' æ®µ';
        }

        function updateButtons() {
            const hasContent = recognizer.segments.length > 0;
            document.getElementById('copyBtn').disabled = !hasContent;
            document.getElementById('exportBtn').disabled = !hasContent;
        }

        // å·¥å…·å‡½æ•°
        function copyText() {
            const text = recognizer.segments.map(s => s.text).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                showToast('å·²å¤åˆ¶', 'success');
            });
        }

        function exportText() {
            const text = recognizer.segments.map(s => `[${new Date(s.startTime).toLocaleTimeString()}] ${s.text}`).join('\n');
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `è½¬å†™_${new Date().toLocaleDateString()}.txt`;
            a.click();
            showToast('å·²å¯¼å‡º', 'success');
        }

        function clearAll() {
            if (recognizer.segments.length === 0) return;
            if (!confirm('ç¡®å®šæ¸…ç©ºå½“å‰å†…å®¹ï¼Ÿ')) return;
            
            recognizer.segments = [];
            transcriptContent.innerHTML = '';
            transcriptContent.appendChild(emptyState);
            emptyState.style.display = 'flex';
            updateStats();
            updateButtons();
            showToast('å·²æ¸…ç©º', 'success');
        }

        function insertPunctuation() {
            // æ™ºèƒ½æ ‡ç‚¹æ’å…¥ï¼ˆåŸºäºåœé¡¿æ£€æµ‹å·²å®ç°ï¼‰
            showToast('å·²æ ¹æ®åœé¡¿è‡ªåŠ¨æ’å…¥æ ‡ç‚¹', 'success');
        }

        function changeLanguage(lang) {
            // å®é™…åº”ç”¨ä¸­éœ€è¦åŠ è½½å¯¹åº”çš„è¯­è¨€æ¨¡å‹
            showToast(`å·²åˆ‡æ¢è¯­è¨€: ${lang}`, 'success');
        }

        // å†å²è®°å½•
        function saveToHistory() {
            const item = {
                id: Date.now(),
                date: new Date().toLocaleString(),
                duration: timeDisplay.textContent,
                segments: recognizer.segments.length,
                text: recognizer.segments.map(s => s.text).join('\n'),
                preview: recognizer.segments[0]?.text?.slice(0, 50) + '...' || 'æ— å†…å®¹'
            };
            
            history.unshift(item);
            if (history.length > 50) history = history.slice(0, 50);
            localStorage.setItem('vs_history', JSON.stringify(history));
            updateHistoryBadge();
        }

        function updateHistoryBadge() {
            const btn = document.getElementById('historyBtn');
            if (history.length > 0) {
                btn.classList.add('has-content');
            }
        }

        function showHistory() {
            const modal = document.getElementById('historyModal');
            const list = document.getElementById('historyList');
            
            if (history.length === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">æš‚æ— å†å²è®°å½•</div>';
            } else {
                list.innerHTML = history.map(item => `
                    <div class="recording-item" onclick="loadHistory(${item.id})">
                        <div class="recording-icon">ğŸ“</div>
                        <div class="recording-info">
                            <div class="recording-name">${item.date}</div>
                            <div class="recording-meta">
                                <span>${item.duration}</span>
                                <span>${item.segments} æ®µ</span>
                                <span>${item.text.length} å­—</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${item.preview}
                            </div>
                        </div>
                        <div class="recording-actions" onclick="event.stopPropagation()">
                            <button class="action-btn" onclick="deleteHistory(${item.id})">ğŸ—‘</button>
                        </div>
                    </div>
                `).join('');
            }
            
            modal.classList.add('show');
        }

        function closeHistory() {
            document.getElementById('historyModal').classList.remove('show');
        }

        function loadHistory(id) {
            const item = history.find(h => h.id === id);
            if (!item) return;
            
            // æ¢å¤åˆ°å½“å‰ç¼–è¾‘å™¨
            recognizer.segments = item.text.split('\n').map((text, i) => ({
                id: Date.now() + i,
                text: text,
                startTime: Date.now(),
                confidence: 1
            }));
            
            // é‡æ–°æ¸²æŸ“
            transcriptContent.innerHTML = '';
            recognizer.segments.forEach(seg => {
                const div = document.createElement('div');
                div.className = 'segment';
                div.innerHTML = `
                    <div class="segment-time">${new Date().toLocaleTimeString()}</div>
                    <div class="segment-text">${escapeHtml(seg.text)}</div>
                `;
                transcriptContent.appendChild(div);
            });
            
            emptyState.style.display = 'none';
            updateStats();
            updateButtons();
            closeHistory();
            showToast('å·²åŠ è½½å†å²è®°å½•', 'success');
        }

        function deleteHistory(id) {
            history = history.filter(h => h.id !== id);
            localStorage.setItem('vs_history', JSON.stringify(history));
            showHistory();
            updateHistoryBadge();
            showToast('å·²åˆ é™¤', 'success');
        }

        // è®¾ç½®
        function showSettings() {
            document.getElementById('settingsModal').classList.add('show');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        function setModel(model, btn) {
            settings.model = model;
            saveSettings();
            updateActiveButton(btn);
            showToast(model === 'fast' ? 'å·²åˆ‡æ¢è‡³æé€Ÿæ¨¡å¼' : 'å·²åˆ‡æ¢è‡³ç²¾å‡†æ¨¡å¼', 'success');
        }

        function setAutoSave(value, btn) {
            settings.autoSave = value;
            saveSettings();
            updateActiveButton(btn);
        }

        function setQuality(quality, btn) {
            settings.quality = quality;
            saveSettings();
            updateActiveButton(btn);
        }

        function updateActiveButton(activeBtn) {
            const parent = activeBtn.parentElement;
            parent.querySelectorAll('.option-btn').forEach(btn => btn.classList.remove('active'));
            activeBtn.classList.add('active');
        }

        function saveSettings() {
            localStorage.setItem('vs_settings', JSON.stringify(settings));
        }

        function loadSettings() {
            // åº”ç”¨è®¾ç½®åˆ° UI
            document.querySelectorAll('.option-btn').forEach(btn => {
                if (btn.textContent.includes('æé€Ÿ') && settings.model === 'fast') btn.classList.add('active');
                if (btn.textContent.includes('ç²¾å‡†') && settings.model === 'accurate') btn.classList.add('active');
                if (btn.textContent === 'å¼€å¯' && settings.autoSave) btn.classList.add('active');
                if (btn.textContent === 'å…³é—­' && !settings.autoSave) btn.classList.add('active');
            });
        }

        // å·¥å…·å‡½æ•°
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // æ€§èƒ½ç›‘æ§ï¼ˆå¯é€‰ï¼‰
        if (window.performance && performance.memory) {
            setInterval(() => {
                const perf = document.getElementById('perfIndicator');
                const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                perf.textContent = `RAM: ${used}MB`;
                perf.classList.add('show');
            }, 2000);
        }

        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);

        // é˜²æ­¢è¯¯å…³é—­
        window.onbeforeunload = (e) => {
            if (isRecording) {
                e.preventDefault();
                e.returnValue = '';
            }
        };
    </script>
</body>
</html>
