<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>èŒè½è®¡æ•°å™¨ Â· ç¦»çº¿ç‰ˆ</title>
    
    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    
    <style>
        :root {
            --primary: #3b82f6;
            --primary-dark: #1d4ed8;
            --secondary: #64748b;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #06b6d4;
            --bg: #0f172a;
            --card: #1e293b;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --roi-color: rgba(255, 215, 0, 0.3);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; overflow-x: hidden; }
        
        .splash { position: fixed; inset: 0; background: linear-gradient(135deg, #1e3a8a 0%, #0f172a 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s; }
        .splash.hidden { opacity: 0; pointer-events: none; }
        .splash-icon { font-size: 100px; margin-bottom: 20px; animation: bounce 2s infinite; }
        @keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-20px)} }
        .splash-text { font-size: 1.8rem; font-weight: 700; margin-bottom: 10px; }
        .splash-subtitle { color: var(--text-muted); margin-bottom: 30px; max-width: 80%; text-align: center; line-height: 1.5; }
        .loading-bar { width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; margin-bottom: 20px; }
        .loading-progress { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s; }
        
        .splash-actions { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; margin-top: 20px; }
        .splash-btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
        .splash-btn-primary { background: var(--primary); color: white; }
        .splash-btn-primary:hover { background: var(--primary-dark); transform: translateY(-2px); }
        .splash-btn-secondary { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); }
        .splash-btn-secondary:hover { background: rgba(255,255,255,0.2); }
        
        .app { max-width: 100vw; min-height: 100vh; display: flex; flex-direction: column; }
        header { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); padding: 20px; text-align: center; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3); position: sticky; top: 0; z-index: 100; }
        h1 { font-size: 1.6rem; font-weight: 700; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .version-badge { background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 12px; font-size: 0.7rem; }
        
        main { flex: 1; padding: 20px; display: flex; flex-direction: column; gap: 20px; max-width: 1200px; margin: 0 auto; width: 100%; }
        
        .upload-card { background: var(--card); border-radius: 24px; padding: 40px 30px; text-align: center; border: 2px dashed var(--secondary); transition: all 0.3s; cursor: pointer; }
        .upload-card:hover, .upload-card.active { border-color: var(--primary); background: rgba(59, 130, 246, 0.1); transform: translateY(-2px); }
        .upload-icon { font-size: 72px; margin-bottom: 20px; opacity: 0.9; }
        .upload-title { font-size: 1.4rem; margin-bottom: 10px; font-weight: 600; }
        .upload-subtitle { color: var(--text-muted); margin-bottom: 30px; font-size: 0.95rem; }
        .upload-tips { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-bottom: 25px; }
        .tip-item { display: flex; align-items: center; gap: 6px; font-size: 0.85rem; color: var(--text-muted); background: var(--bg); padding: 6px 12px; border-radius: 20px; }
        .btn-group { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .btn { padding: 14px 28px; border: none; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5); }
        .btn-secondary { background: var(--secondary); color: white; }
        .btn-secondary:hover { background: #475569; }
        input[type="file"] { display: none; }
        
        .viewer { display: none; flex-direction: column; gap: 20px; animation: fadeIn 0.5s; }
        .viewer.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .control-panel { background: var(--card); border-radius: 20px; padding: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .control-section { display: flex; flex-direction: column; gap: 12px; }
        .section-title { font-size: 0.9rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .slider-group { display: flex; flex-direction: column; gap: 8px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; }
        .slider-label { font-size: 0.9rem; }
        .slider-value { background: var(--bg); padding: 4px 10px; border-radius: 6px; font-size: 0.85rem; font-weight: 600; color: var(--primary); min-width: 40px; text-align: center; }
        input[type="range"] { width: 100%; height: 6px; -webkit-appearance: none; background: var(--bg); border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: var(--primary); border-radius: 50%; cursor: pointer; transition: transform 0.2s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        
        select { width: 100%; padding: 8px; border-radius: 6px; background: var(--bg); color: var(--text); border: 1px solid var(--secondary); font-size: 0.9rem; }
        
        .action-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .btn-small { padding: 10px 16px; font-size: 0.85rem; }
        .btn-success { background: var(--success); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-info { background: var(--info); color: white; }
        .btn-outline { background: transparent; border: 1px solid var(--secondary); color: var(--text); }
        
        .mode-indicator { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: rgba(59, 130, 246, 0.2); color: var(--primary); border-radius: 20px; font-size: 0.9rem; font-weight: 600; }
        .mode-indicator.manual { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .mode-indicator.roi { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        
        .image-wrapper { position: relative; background: var(--card); border-radius: 20px; overflow: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.4); max-height: 70vh; }
        .canvas-container { position: relative; display: inline-block; min-width: 100%; }
        #mainCanvas { display: block; width: auto; height: auto; background: #1e293b; max-width: none; }
        .overlay-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .roi-marker { position: absolute; border: 3px solid gold; border-radius: 50%; background: var(--roi-color); pointer-events: none; box-shadow: 0 0 0 2px rgba(0,0,0,0.3); display: none; }
        
        .colony-marker { position: absolute; transform: translate(-50%, -50%); pointer-events: auto; cursor: pointer; z-index: 10; transition: all 0.2s; }
        .marker-center { width: 6px; height: 6px; background: #00ff88; border: 1px solid white; border-radius: 50%; box-shadow: 0 1px 4px rgba(0,0,0,0.5); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .marker-circle { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #ff4757; border-radius: 50%; opacity: 0.7; }
        .colony-marker:hover { z-index: 20; transform: translate(-50%, -50%) scale(1.3); }
        .colony-marker:hover .marker-center { background: #ff4757; }
        .colony-marker.manual .marker-center { background: #ffd700; }
        .colony-marker.manual .marker-circle { border-color: #ffd700; }
        .marker-tooltip { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: white; padding: 6px 10px; border-radius: 6px; font-size: 11px; white-space: nowrap; opacity: 0; transition: opacity 0.2s; pointer-events: none; margin-bottom: 5px; z-index: 30; }
        .colony-marker:hover .marker-tooltip { opacity: 1; }
        
        .stats-panel { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; }
        .stat-box { background: var(--card); border-radius: 16px; padding: 20px; text-align: center; border: 1px solid rgba(255,255,255,0.1); transition: transform 0.2s; }
        .stat-box:hover { transform: translateY(-2px); border-color: var(--primary); }
        .stat-number { font-size: 2.2rem; font-weight: 700; color: var(--primary); display: block; line-height: 1; }
        .stat-label { font-size: 0.85rem; color: var(--text-muted); margin-top: 8px; }
        .stat-box.success .stat-number { color: var(--success); }
        .stat-box.warning .stat-number { color: var(--warning); }
        .stat-box.info .stat-number { color: var(--info); }
        
        .loading-overlay { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(10px); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 9998; }
        .loading-overlay.active { display: flex; }
        .spinner { width: 60px; height: 60px; border: 4px solid rgba(59, 130, 246, 0.2); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { margin-top: 20px; font-size: 1.1rem; color: var(--text); }
        .loading-subtext { margin-top: 10px; font-size: 0.9rem; color: var(--text-muted); }
        
        .toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); background: var(--card); color: var(--text); padding: 16px 24px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1); opacity: 0; transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55); z-index: 10000; display: flex; align-items: center; gap: 10px; font-weight: 500; max-width: 90%; text-align: center; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        .algo-info { background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--primary); padding: 12px 16px; border-radius: 0 8px 8px 0; font-size: 0.85rem; color: var(--text-muted); }
        .param-tip { font-size: 0.75rem; color: var(--success); margin-top: 4px; }
        
        .model-status { display: inline-flex; align-items: center; gap: 6px; font-size: 0.8rem; padding: 4px 10px; border-radius: 12px; background: var(--bg); }
        .model-status.ready { color: var(--success); }
        .model-status.loading { color: var(--warning); animation: pulse 1.5s infinite; }
        .model-status.error { color: var(--danger); }
        .model-status.local { color: var(--info); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .model-selector { background: var(--card); border-radius: 12px; padding: 20px; margin-top: 20px; max-width: 500px; width: 90%; }
        .model-selector-title { font-size: 1rem; font-weight: 600; margin-bottom: 15px; color: var(--text); }
        .model-option { display: flex; align-items: center; gap: 10px; padding: 12px; background: var(--bg); border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; }
        .model-option:hover { border-color: var(--primary); }
        .model-option.selected { border-color: var(--primary); background: rgba(59, 130, 246, 0.1); }
        .model-option-icon { font-size: 1.5rem; }
        .model-option-info { flex: 1; text-align: left; }
        .model-option-name { font-weight: 600; font-size: 0.9rem; }
        .model-option-desc { font-size: 0.8rem; color: var(--text-muted); margin-top: 2px; }
        
        .fallback-notice { background: rgba(245, 158, 11, 0.1); border: 1px solid var(--warning); border-radius: 8px; padding: 12px; margin-top: 15px; font-size: 0.85rem; color: var(--text-muted); }
        
        .debug-info { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px; border-radius: 6px; font-family: monospace; font-size: 0.75rem; max-width: 300px; z-index: 9999; display: none; }
        .debug-info.show { display: block; }
        
        @media (max-width: 768px) { h1 { font-size: 1.3rem; } .upload-title { font-size: 1.2rem; } .control-panel { grid-template-columns: 1fr; } .stats-panel { grid-template-columns: repeat(2, 1fr); } .splash-actions { flex-direction: column; width: 100%; padding: 0 20px; } .splash-btn { width: 100%; justify-content: center; } }
    </style>
</head>
<body>
    <!-- è°ƒè¯•ä¿¡æ¯é¢æ¿ -->
    <div class="debug-info" id="debugInfo"></div>
    
    <div class="splash" id="splash">
        <div class="splash-icon">ğŸ”¬</div>
        <div class="splash-text">èŒè½è®¡æ•°å™¨ Â· ç¦»çº¿ç‰ˆ</div>
        <div class="splash-subtitle" id="splashSubtitle">å‡†å¤‡åŠ è½½æ¨¡å‹...</div>
        
        <div class="loading-bar" id="loadingBar" style="display: none;">
            <div class="loading-progress" id="loadingProgress" style="width: 0%"></div>
        </div>
        
        <div class="model-selector" id="modelSelector">
            <div class="model-selector-title">ğŸ“¦ é€‰æ‹©æ¨¡å‹åŠ è½½æ–¹å¼</div>
            
            <div class="model-option selected" onclick="selectModelSource('local')" id="optionLocal">
                <div class="model-option-icon">ğŸ’»</div>
                <div class="model-option-info">
                    <div class="model-option-name">æœ¬åœ°ä¸Šä¼ ï¼ˆæ¨èï¼‰</div>
                    <div class="model-option-desc">ä¸Šä¼  .onnx æ¨¡å‹æ–‡ä»¶ï¼Œæ— éœ€ç½‘ç»œ</div>
                </div>
            </div>
            
            <div class="model-option" onclick="selectModelSource('url')" id="optionUrl">
                <div class="model-option-icon">ğŸŒ</div>
                <div class="model-option-info">
                    <div class="model-option-name">URLä¸‹è½½</div>
                    <div class="model-option-desc">ä»å¯è®¿é—®çš„URLä¸‹è½½æ¨¡å‹</div>
                </div>
            </div>
            
            <div class="model-option" onclick="selectModelSource('cv')" id="optionCv">
                <div class="model-option-icon">âš«</div>
                <div class="model-option-info">
                    <div class="model-option-name">ä»…ä½¿ç”¨ä¼ ç»ŸCVï¼ˆæ— éœ€æ¨¡å‹ï¼‰</div>
                    <div class="model-option-desc">çº¯JavaScriptå›¾åƒå¤„ç†ï¼Œæ°¸ä¹…å¯ç”¨</div>
                </div>
            </div>
            
            <div class="fallback-notice" id="fallbackNotice" style="display: none;">
                âš ï¸ åŠ è½½å¤±è´¥ï¼Œå»ºè®®åˆ‡æ¢åˆ°ä¼ ç»ŸCVæ¨¡å¼
            </div>
            
            <div class="splash-actions" style="margin-top: 20px;">
                <button class="splash-btn splash-btn-primary" onclick="confirmModelSource()">
                    <span>âœ“</span><span>ç¡®è®¤é€‰æ‹©</span>
                </button>
            </div>
            
            <input type="file" id="modelFileInput" accept=".onnx" style="display: none;" onchange="handleModelFile(event)">
            
            <!-- URLè¾“å…¥æ¡†ï¼ˆé»˜è®¤éšè—ï¼‰ -->
            <div id="urlInputContainer" style="display: none; margin-top: 15px;">
                <input type="text" id="modelUrlInput" placeholder="è¾“å…¥æ¨¡å‹URLï¼ˆ.onnxæ–‡ä»¶ç›´é“¾ï¼‰" 
                       style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid var(--secondary); background: var(--bg); color: var(--text);">
            </div>
        </div>
        
        <div id="loadingStatus" style="display: none; margin-top: 20px; text-align: center;">
            <div class="model-status loading">
                <span>â³</span><span id="loadingText">æ­£åœ¨åŠ è½½...</span>
            </div>
            <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 10px;" id="loadingDetail"></div>
        </div>
    </div>
    
    <div class="app">
        <header>
            <h1><span>ğŸ”¬</span><span>èŒè½è®¡æ•°å™¨ Pro</span><span class="version-badge" id="versionBadge">CVæ¨¡å¼</span></h1>
            <div style="margin-top: 8px; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                <span class="model-status local" id="modelStatus">
                    <span>âš«</span><span>ä¼ ç»ŸCVç®—æ³•å°±ç»ª</span>
                </span>
                <button class="btn-small btn-outline" onclick="toggleDebug()" style="padding: 4px 12px; font-size: 0.75rem;">
                    è°ƒè¯•ä¿¡æ¯
                </button>
                <button class="btn-small btn-outline" onclick="switchModel()" id="switchModelBtn" style="padding: 4px 12px; font-size: 0.75rem;">
                    åˆ‡æ¢æ¨¡å¼
                </button>
            </div>
        </header>
        
        <main>
            <div class="upload-card" id="uploadCard">
                <div class="upload-icon">ğŸ“¤</div>
                <div class="upload-title">æ‹–æ”¾å›¾ç‰‡æˆ–ç‚¹å‡»ä¸Šä¼ </div>
                <div class="upload-subtitle" id="uploadSubtitle">æ”¯æŒæ‹ç…§ä¸Šä¼  Â· è‡ªåŠ¨èŒè½è®¡æ•°</div>
                <div class="upload-tips">
                    <div class="tip-item"><span id="algoIcon">âš«</span><span id="algoText">ä¼ ç»ŸCVç®—æ³•</span></div>
                    <div class="tip-item"><span>ğŸ’¡</span><span>å…‰çº¿å‡åŒ€</span></div>
                    <div class="tip-item"><span>ğŸ¯</span><span>å¯ä½¿ç”¨ROI</span></div>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()"><span>ğŸ“</span><span>é€‰æ‹©æ–‡ä»¶</span></button>
                    <button class="btn btn-secondary" onclick="document.getElementById('cameraInput').click()"><span>ğŸ“·</span><span>æ‹ç…§</span></button>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                <input type="file" id="cameraInput" accept="image/*" capture="environment">
            </div>
            
            <div class="viewer" id="viewer">
                <div class="control-panel">
                    <!-- YOLOå‚æ•°ï¼ˆé»˜è®¤éšè—ï¼‰ -->
                    <div class="control-section" id="yoloParams" style="display: none;">
                        <div class="section-title">ğŸ¤– YOLOæ£€æµ‹å‚æ•°</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">ç½®ä¿¡åº¦é˜ˆå€¼</span><span class="slider-value" id="confValue">0.25</span></div>
                            <input type="range" id="confThreshold" min="0.1" max="0.9" value="0.25" step="0.05">
                            <div class="param-tip">æ¨è0.2-0.3ï¼ˆè¶Šä½æ£€æµ‹è¶Šå¤šï¼‰</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">IoUé˜ˆå€¼ï¼ˆNMSï¼‰</span><span class="slider-value" id="iouValue">0.45</span></div>
                            <input type="range" id="iouThreshold" min="0.1" max="0.9" value="0.45" step="0.05">
                            <div class="param-tip">å»é™¤é‡å æ¡†ï¼Œæ¨è0.4-0.5</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">è¾“å…¥å°ºå¯¸</span></div>
                            <select id="inputSize">
                                <option value="640" selected>640x640ï¼ˆæ¨èï¼‰</option>
                                <option value="320">320x320ï¼ˆå¿«é€Ÿï¼‰</option>
                            </select>
                        </div>
                        <div class="algo-info">
                            ä½¿ç”¨YOLOæ·±åº¦å­¦ä¹ æ¨¡å‹è¿›è¡ŒèŒè½æ£€æµ‹
                        </div>
                    </div>
                    
                    <!-- ä¼ ç»ŸCVå‚æ•°ï¼ˆé»˜è®¤æ˜¾ç¤ºï¼‰ -->
                    <div class="control-section" id="cvParams">
                        <div class="section-title">âš™ï¸ ä¼ ç»ŸCVæ£€æµ‹å‚æ•°</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">äº®åº¦é˜ˆå€¼</span><span class="slider-value" id="thresholdValue">128</span></div>
                            <input type="range" id="threshold" min="50" max="250" value="128" step="5">
                            <div class="param-tip">èŒè½äº®åº¦é˜ˆå€¼ï¼Œæ ¹æ®å›¾ç‰‡è°ƒæ•´</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">æœ€å°èŒè½é¢ç§¯</span><span class="slider-value" id="minAreaValue">10</span></div>
                            <input type="range" id="minArea" min="5" max="100" value="10" step="5">
                            <div class="param-tip">è¿‡æ»¤å¤ªå°çš„å™ªå£°ç‚¹</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">æœ€å¤§èŒè½é¢ç§¯</span><span class="slider-value" id="maxAreaValue">500</span></div>
                            <input type="range" id="maxArea" min="100" max="2000" value="500" step="50">
                            <div class="param-tip">è¿‡æ»¤è¿‡å¤§çš„æ‚è´¨</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">åœ†å½¢åº¦é˜ˆå€¼</span><span class="slider-value" id="circularityValue">0.7</span></div>
                            <input type="range" id="circularity" min="0.3" max="1.0" value="0.7" step="0.05">
                            <div class="param-tip">è¶Šæ¥è¿‘1è¶Šåœ†ï¼ŒèŒè½é€šå¸¸0.6-0.9</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">è†¨èƒ€/è…èš€è¿­ä»£</span><span class="slider-value" id="morphValue">1</span></div>
                            <input type="range" id="morphIterations" min="0" max="5" value="1" step="1">
                            <div class="param-tip">å½¢æ€å­¦æ“ä½œï¼Œè¿æ¥æ–­è£‚èŒè½</div>
                        </div>
                        <div class="algo-info">
                            ä½¿ç”¨JavaScriptå®ç°å›¾åƒå¤„ç†ï¼šç°åº¦â†’é˜ˆå€¼â†’å½¢æ€å­¦â†’è½®å»“åˆ†æâ†’åœ†å½¢åº¦è¿‡æ»¤
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">ğŸ–¼ï¸ é¢„å¤„ç† / ROI</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">å¯¹æ¯”åº¦å¢å¼º</span><span class="slider-value" id="contrastValue">1.0</span></div>
                            <input type="range" id="contrast" min="0.5" max="3.0" value="1.0" step="0.1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">é«˜æ–¯æ¨¡ç³ŠåŠå¾„</span><span class="slider-value" id="blurValue">1</span></div>
                            <input type="range" id="blurRadius" min="0" max="5" value="1" step="1">
                            <div class="param-tip">å»å™ªï¼Œ0è¡¨ç¤ºä¸æ¨¡ç³Š</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">åç›¸æ¨¡å¼</span></div>
                            <select id="invertMode">
                                <option value="auto" selected>è‡ªåŠ¨æ£€æµ‹</option>
                                <option value="normal">æ­£å¸¸ï¼ˆèŒè½äº®èƒŒæ™¯æš—ï¼‰</option>
                                <option value="inverted">åç›¸ï¼ˆèŒè½æš—èƒŒæ™¯äº®ï¼‰</option>
                            </select>
                        </div>
                        <div class="action-buttons">
                            <button class="btn btn-warning btn-small" id="selectRoiBtn">ğŸ¯ é€‰æ‹©åŸ¹å…»çš¿</button>
                            <button class="btn btn-outline btn-small" id="clearRoiBtn">ğŸ—‘ï¸ æ¸…é™¤ROI</button>
                        </div>
                        <div class="mode-indicator" id="roiIndicator" style="display: none;"><span>â­•</span><span>ROIå·²è®¾å®š</span></div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">ğŸ§¹ åå¤„ç† / æ“ä½œ</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">åˆå¹¶è·ç¦»</span><span class="slider-value" id="mergeDistValue">15</span></div>
                            <input type="range" id="mergeDist" min="5" max="50" value="15" step="5">
                            <div class="param-tip">åˆå¹¶é‡å èŒè½çš„è·ç¦»é˜ˆå€¼</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">å›¾åƒç¼©æ”¾</span><span class="slider-value" id="zoomValue">1.00</span></div>
                            <input type="range" id="zoomSlider" min="0.05" max="3.0" value="1.0" step="0.05">
                        </div>
                        <div class="action-buttons">
                            <button class="btn btn-primary btn-small" id="analyzeBtn">ğŸ”„ é‡æ–°åˆ†æ</button>
                            <button class="btn btn-success btn-small" id="addModeBtn">â• æ‰‹åŠ¨æ·»åŠ </button>
                            <button class="btn btn-info btn-small" id="toggleCirclesBtn">â­• æ˜¾éšåœ†åœˆ</button>
                            <button class="btn btn-outline btn-small" id="resetParamsBtn">â†º æ¢å¤é»˜è®¤</button>
                            <button class="btn btn-outline btn-small" id="exportImgBtn">ğŸ“¸ å¯¼å‡ºå›¾ç‰‡</button>
                            <button class="btn btn-danger btn-small" id="clearBtn">ğŸ—‘ï¸ æ¸…ç©º</button>
                            <button class="btn btn-outline btn-small" id="backBtn">â†©ï¸ æ–°å›¾ç‰‡</button>
                        </div>
                    </div>
                </div>
                
                <div class="image-wrapper" id="imageWrapper">
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="mainCanvas"></canvas>
                        <div class="overlay-layer" id="overlayLayer">
                            <div id="roiVisual" class="roi-marker"></div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-panel">
                    <div class="stat-box"><span class="stat-number" id="statTotal">0</span><div class="stat-label">æ€»èŒè½æ•°</div></div>
                    <div class="stat-box success"><span class="stat-number" id="statAuto">0</span><div class="stat-label" id="statAutoLabel">è‡ªåŠ¨æ£€æµ‹</div></div>
                    <div class="stat-box warning"><span class="stat-number" id="statManual">0</span><div class="stat-label">æ‰‹åŠ¨æ·»åŠ </div></div>
                    <div class="stat-box info"><span class="stat-number" id="statAvgRadius">0</span><div class="stat-label">å¹³å‡åŠå¾„(px)</div></div>
                </div>
            </div>
        </main>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="overlayLoadingText">åˆ†æä¸­...</div>
        <div class="loading-subtext" id="overlayLoadingSub">è¯·ç¨å€™</div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== è°ƒè¯•åŠŸèƒ½ ====================
        function log(msg) {
            console.log(msg);
            const debug = document.getElementById('debugInfo');
            debug.innerHTML += msg + '<br>';
            debug.scrollTop = debug.scrollHeight;
        }
        
        function toggleDebug() {
            document.getElementById('debugInfo').classList.toggle('show');
        }
        
        // ==================== æ¨¡å‹åŠ è½½é…ç½® ====================
        let currentModelSource = 'cv'; // é»˜è®¤CVæ¨¡å¼
        let session = null;
        let modelLoaded = false;
        let useYOLO = false;
        
        // ==================== å…¨å±€çŠ¶æ€ ====================
        let currentImage = null;
        let originalImageData = null; // ä¿å­˜åŸå§‹å›¾åƒæ•°æ®
        let colonies = [];
        let isAddMode = false;
        let showCircles = true;
        let roiCenter = null;
        let roiRadius = null;
        let isRoiMode = false;
        let roiStart = null;
        
        const uploadCard = document.getElementById('uploadCard');
        const viewer = document.getElementById('viewer');
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true }); // ä¼˜åŒ–é¢‘ç¹è¯»å–
        const overlayLayer = document.getElementById('overlayLayer');
        const roiVisual = document.getElementById('roiVisual');
        const imageWrapper = document.getElementById('imageWrapper');
        const modelStatus = document.getElementById('modelStatus');
        const versionBadge = document.getElementById('versionBadge');
        
        // ==================== æ¨¡å‹é€‰æ‹©ç•Œé¢ ====================
        
        function selectModelSource(source) {
            currentModelSource = source;
            
            document.querySelectorAll('.model-option').forEach(el => {
                el.classList.remove('selected');
            });
            document.getElementById('option' + source.charAt(0).toUpperCase() + source.slice(1)).classList.add('selected');
            
            // æ˜¾ç¤º/éšè—URLè¾“å…¥æ¡†
            document.getElementById('urlInputContainer').style.display = source === 'url' ? 'block' : 'none';
            
            if (source === 'local') {
                setTimeout(() => {
                    document.getElementById('modelFileInput').click();
                }, 100);
            }
        }
        
        function confirmModelSource() {
            if (currentModelSource === 'cv') {
                // ç›´æ¥è¿›å…¥CVæ¨¡å¼
                useYOLO = false;
                modelLoaded = false;
                document.getElementById('splash').classList.add('hidden');
                updateAlgoUI();
                showToast('âœ… å·²è¿›å…¥ä¼ ç»ŸCVæ¨¡å¼ï¼Œå¯ç›´æ¥ä¸Šä¼ å›¾ç‰‡åˆ†æ');
            } else if (currentModelSource === 'local') {
                document.getElementById('modelFileInput').click();
            } else if (currentModelSource === 'url') {
                const url = document.getElementById('modelUrlInput').value.trim();
                if (!url) {
                    showToast('âŒ è¯·è¾“å…¥æ¨¡å‹URL');
                    return;
                }
                loadModelFromUrl(url, 'è‡ªå®šä¹‰URL');
            }
        }
        
        async function handleModelFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.onnx')) {
                showToast('âŒ è¯·é€‰æ‹© .onnx æ ¼å¼çš„æ¨¡å‹æ–‡ä»¶');
                return;
            }
            
            document.getElementById('modelSelector').style.display = 'none';
            document.getElementById('loadingStatus').style.display = 'block';
            document.getElementById('loadingText').textContent = 'æ­£åœ¨åŠ è½½æœ¬åœ°æ¨¡å‹...';
            document.getElementById('loadingDetail').textContent = file.name;
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                
                const ortConfig = {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                    wasmOptions: { numThreads: 2, simd: true }
                };
                
                session = await ort.InferenceSession.create(arrayBuffer, ortConfig);
                modelLoaded = true;
                useYOLO = true;
                
                document.getElementById('splash').classList.add('hidden');
                updateAlgoUI();
                showToast(`âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼š${file.name}`);
                
                // ä¿å­˜åˆ°ç¼“å­˜
                await saveModelToCache(arrayBuffer, file.name);
                
            } catch (error) {
                console.error('æœ¬åœ°æ¨¡å‹åŠ è½½å¤±è´¥:', error);
                log('æ¨¡å‹åŠ è½½å¤±è´¥: ' + error.message);
                showToast('âŒ æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå·²åˆ‡æ¢åˆ°CVæ¨¡å¼');
                
                useYOLO = false;
                modelLoaded = false;
                document.getElementById('splash').classList.add('hidden');
                updateAlgoUI();
            }
        }
        
        async function loadModelFromUrl(url, sourceName) {
            document.getElementById('modelSelector').style.display = 'none';
            document.getElementById('loadingStatus').style.display = 'block';
            document.getElementById('loadingBar').style.display = 'block';
            document.getElementById('loadingText').textContent = 'æ­£åœ¨ä¸‹è½½æ¨¡å‹...';
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const contentLength = response.headers.get('content-length');
                const total = contentLength ? parseInt(contentLength) : 0;
                const reader = response.body.getReader();
                const chunks = [];
                let received = 0;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    received += value.length;
                    
                    if (total > 0) {
                        const percent = ((received / total) * 100).toFixed(0);
                        document.getElementById('loadingProgress').style.width = percent + '%';
                        document.getElementById('loadingDetail').textContent = 
                            `å·²ä¸‹è½½ ${(received/1024/1024).toFixed(1)}MB`;
                    }
                }
                
                const arrayBuffer = new Uint8Array(received);
                let position = 0;
                for (const chunk of chunks) {
                    arrayBuffer.set(chunk, position);
                    position += chunk.length;
                }
                
                document.getElementById('loadingText').textContent = 'æ­£åœ¨åˆå§‹åŒ–...';
                
                const ortConfig = {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                    wasmOptions: { numThreads: 2, simd: true }
                };
                
                session = await ort.InferenceSession.create(arrayBuffer.buffer, ortConfig);
                modelLoaded = true;
                useYOLO = true;
                
                document.getElementById('splash').classList.add('hidden');
                updateAlgoUI();
                showToast(`âœ… ${sourceName}æ¨¡å‹åŠ è½½æˆåŠŸ`);
                
            } catch (error) {
                console.error('URLåŠ è½½å¤±è´¥:', error);
                showToast('âŒ ä¸‹è½½å¤±è´¥ï¼Œå·²åˆ‡æ¢åˆ°CVæ¨¡å¼');
                useYOLO = false;
                document.getElementById('splash').classList.add('hidden');
                updateAlgoUI();
            }
        }
        
        // ==================== IndexedDBç¼“å­˜ ====================
        
        const DB_NAME = 'ColonyCounterDB';
        const STORE_NAME = 'models';
        
        async function saveModelToCache(arrayBuffer, name) {
            try {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => {
                    e.target.result.createObjectStore(STORE_NAME, { keyPath: 'name' });
                };
                
                const db = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                await store.put({ name, data: arrayBuffer, timestamp: Date.now() });
                log('æ¨¡å‹å·²ç¼“å­˜');
            } catch (e) {
                log('ç¼“å­˜å¤±è´¥: ' + e.message);
            }
        }
        
        // ==================== UIæ›´æ–° ====================
        
        function updateAlgoUI() {
            if (useYOLO && modelLoaded) {
                versionBadge.textContent = 'YOLO';
                modelStatus.className = 'model-status ready';
                modelStatus.innerHTML = '<span>âœ…</span><span>YOLOæ¨¡å‹å°±ç»ª</span>';
                document.getElementById('algoIcon').textContent = 'ğŸ¤–';
                document.getElementById('algoText').textContent = 'YOLOæ·±åº¦å­¦ä¹ ';
                document.getElementById('statAutoLabel').textContent = 'YOLOæ£€æµ‹';
                document.getElementById('yoloParams').style.display = 'flex';
                document.getElementById('cvParams').style.display = 'none';
            } else {
                versionBadge.textContent = 'CVæ¨¡å¼';
                modelStatus.className = 'model-status local';
                modelStatus.innerHTML = '<span>âš«</span><span>ä¼ ç»ŸCVç®—æ³•å°±ç»ª</span>';
                document.getElementById('algoIcon').textContent = 'âš«';
                document.getElementById('algoText').textContent = 'å›¾åƒå¤„ç†ç®—æ³•';
                document.getElementById('statAutoLabel').textContent = 'CVæ£€æµ‹';
                document.getElementById('yoloParams').style.display = 'none';
                document.getElementById('cvParams').style.display = 'flex';
            }
        }
        
        function switchModel() {
            document.getElementById('splash').classList.remove('hidden');
            document.getElementById('modelSelector').style.display = 'block';
            document.getElementById('loadingStatus').style.display = 'none';
            document.getElementById('loadingBar').style.display = 'none';
        }
        
        // ==================== æ ¸å¿ƒï¼šä¼ ç»ŸCVç®—æ³•ï¼ˆå®Œå…¨é‡å†™ï¼‰ ====================
        
        // å›¾åƒå¤„ç†å·¥å…·å‡½æ•°
        const ImageUtils = {
            // è½¬æ¢ä¸ºç°åº¦å›¾
            toGrayscale: (imageData) => {
                const { data, width, height } = imageData;
                const gray = new Uint8Array(width * height);
                for (let i = 0; i < data.length; i += 4) {
                    // æ ‡å‡†ç°åº¦è½¬æ¢
                    gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                }
                return { data: gray, width, height };
            },
            
            // é«˜æ–¯æ¨¡ç³Š
            gaussianBlur: (grayImage, radius) => {
                if (radius <= 0) return grayImage;
                
                const { data, width, height } = grayImage;
                const output = new Uint8Array(width * height);
                
                // åˆ›å»ºé«˜æ–¯æ ¸
                const size = radius * 2 + 1;
                const kernel = new Float32Array(size);
                const sigma = radius / 3;
                let sum = 0;
                
                for (let i = 0; i < size; i++) {
                    const x = i - radius;
                    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
                    sum += kernel[i];
                }
                
                // å½’ä¸€åŒ–
                for (let i = 0; i < size; i++) kernel[i] /= sum;
                
                // æ°´å¹³æ¨¡ç³Š
                const temp = new Float32Array(width * height);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let val = 0;
                        for (let k = -radius; k <= radius; k++) {
                            const px = Math.min(width - 1, Math.max(0, x + k));
                            val += data[y * width + px] * kernel[k + radius];
                        }
                        temp[y * width + x] = val;
                    }
                }
                
                // å‚ç›´æ¨¡ç³Š
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let val = 0;
                        for (let k = -radius; k <= radius; k++) {
                            const py = Math.min(height - 1, Math.max(0, y + k));
                            val += temp[py * width + x] * kernel[k + radius];
                        }
                        output[y * width + x] = Math.round(val);
                    }
                }
                
                return { data: output, width, height };
            },
            
            // é˜ˆå€¼å¤„ç†
            threshold: (grayImage, thresh, invert = false) => {
                const { data, width, height } = grayImage;
                const binary = new Uint8Array(width * height);
                
                for (let i = 0; i < data.length; i++) {
                    if (invert) {
                        binary[i] = data[i] < thresh ? 255 : 0;
                    } else {
                        binary[i] = data[i] > thresh ? 255 : 0;
                    }
                }
                
                return { data: binary, width, height };
            },
            
            // å½¢æ€å­¦è†¨èƒ€
            dilate: (binaryImage, iterations) => {
                let { data, width, height } = binaryImage;
                
                for (let iter = 0; iter < iterations; iter++) {
                    const newData = new Uint8Array(width * height);
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            let maxVal = 0;
                            // 3x3æ ¸
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                        maxVal = Math.max(maxVal, data[ny * width + nx]);
                                    }
                                }
                            }
                            newData[y * width + x] = maxVal;
                        }
                    }
                    
                    data = newData;
                }
                
                return { data, width, height };
            },
            
            // å½¢æ€å­¦è…èš€
            erode: (binaryImage, iterations) => {
                let { data, width, height } = binaryImage;
                
                for (let iter = 0; iter < iterations; iter++) {
                    const newData = new Uint8Array(width * height);
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            let minVal = 255;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                        minVal = Math.min(minVal, data[ny * width + nx]);
                                    }
                                }
                            }
                            newData[y * width + x] = minVal;
                        }
                    }
                    
                    data = newData;
                }
                
                return { data, width, height };
            },
            
            // æŸ¥æ‰¾è½®å»“ï¼ˆç®€åŒ–ç‰ˆ - åŸºäºè¿é€šåŸŸï¼‰
            findContours: (binaryImage) => {
                const { data, width, height } = binaryImage;
                const visited = new Uint8Array(width * height);
                const contours = [];
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        if (data[idx] === 255 && !visited[idx]) {
                            // æ‰¾åˆ°æ–°è¿é€šåŸŸï¼Œä½¿ç”¨æ´ªæ°´å¡«å……
                            const contour = [];
                            const stack = [idx];
                            visited[idx] = 1;
                            
                            let minX = x, maxX = x, minY = y, maxY = y;
                            
                            while (stack.length > 0) {
                                const curr = stack.pop();
                                const cx = curr % width;
                                const cy = Math.floor(curr / width);
                                
                                contour.push({ x: cx, y: cy });
                                
                                // æ›´æ–°è¾¹ç•Œ
                                minX = Math.min(minX, cx);
                                maxX = Math.max(maxX, cx);
                                minY = Math.min(minY, cy);
                                maxY = Math.max(maxY, cy);
                                
                                // æ£€æŸ¥4é‚»åŸŸ
                                const neighbors = [
                                    curr - 1, curr + 1,
                                    curr - width, curr + width
                                ];
                                
                                for (const n of neighbors) {
                                    const nx = n % width;
                                    const ny = Math.floor(n / width);
                                    
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height &&
                                        data[n] === 255 && !visited[n]) {
                                        visited[n] = 1;
                                        stack.push(n);
                                    }
                                }
                            }
                            
                            if (contour.length > 10) { // è¿‡æ»¤å¤ªå°çš„å™ªå£°
                                contours.push({
                                    points: contour,
                                    area: contour.length,
                                    bbox: { x: minX, y: minY, width: maxX - minX, height: maxY - minY }
                                });
                            }
                        }
                    }
                }
                
                return contours;
            },
            
            // è®¡ç®—åœ†å½¢åº¦
            calculateCircularity: (contour) => {
                const { area, bbox } = contour;
                const radius = Math.sqrt(area / Math.PI);
                const perimeter = 2 * Math.PI * radius;
                
                // ç®€åŒ–çš„åœ†å½¢åº¦è®¡ç®—ï¼š4Ï€Ã—é¢ç§¯/å‘¨é•¿Â²
                // è¿™é‡Œç”¨è¾¹ç•Œæ¡†è¿‘ä¼¼
                const boxArea = bbox.width * bbox.height;
                const circularity = area / boxArea; // è¶Šåœ†è¶Šæ¥è¿‘Ï€/4â‰ˆ0.785
                
                return circularity;
            }
        };
        
        // ä¸»åˆ†æå‡½æ•°
        function analyzeCV() {
            if (!currentImage || !originalImageData) {
                showToast('âŒ æ²¡æœ‰å›¾åƒæ•°æ®');
                return;
            }
            
            log('å¼€å§‹CVåˆ†æ...');
            document.getElementById('loadingOverlay').classList.add('active');
            document.getElementById('overlayLoadingText').textContent = 'CVåˆ†æä¸­...';
            document.getElementById('overlayLoadingSub').textContent = 'å›¾åƒé¢„å¤„ç† â†’ é˜ˆå€¼åˆ†å‰² â†’ è½®å»“æ£€æµ‹';
            
            // ä½¿ç”¨setTimeoutè®©UIæ›´æ–°
            setTimeout(() => {
                try {
                    const params = {
                        threshold: parseInt(document.getElementById('threshold').value),
                        minArea: parseInt(document.getElementById('minArea').value),
                        maxArea: parseInt(document.getElementById('maxArea').value),
                        circularity: parseFloat(document.getElementById('circularity').value),
                        morphIterations: parseInt(document.getElementById('morphIterations').value),
                        contrast: parseFloat(document.getElementById('contrast').value),
                        blurRadius: parseInt(document.getElementById('blurRadius').value),
                        invertMode: document.getElementById('invertMode').value,
                        mergeDist: parseInt(document.getElementById('mergeDist').value)
                    };
                    
                    log(`å‚æ•°: é˜ˆå€¼=${params.threshold}, é¢ç§¯=${params.minArea}-${params.maxArea}, åœ†åº¦=${params.circularity}`);
                    
                    // 1. è·å–å›¾åƒæ•°æ®ï¼ˆåº”ç”¨å¯¹æ¯”åº¦ï¼‰
                    let imageData;
                    if (params.contrast !== 1.0) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = originalImageData.width;
                        tempCanvas.height = originalImageData.height;
                        const tCtx = tempCanvas.getContext('2d');
                        tCtx.filter = `contrast(${params.contrast})`;
                        tCtx.drawImage(currentImage, 0, 0);
                        imageData = tCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    } else {
                        imageData = originalImageData;
                    }
                    
                    // 2. è½¬ç°åº¦
                    let gray = ImageUtils.toGrayscale(imageData);
                    log(`ç°åº¦å›¾: ${gray.width}x${gray.height}`);
                    
                    // 3. é«˜æ–¯æ¨¡ç³Šå»å™ª
                    if (params.blurRadius > 0) {
                        gray = ImageUtils.gaussianBlur(gray, params.blurRadius);
                        log('é«˜æ–¯æ¨¡ç³Šå®Œæˆ');
                    }
                    
                    // 4. è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦éœ€è¦åç›¸
                    let needInvert = false;
                    if (params.invertMode === 'auto') {
                        // è®¡ç®—å›¾åƒä¸­å¿ƒåŒºåŸŸçš„å¹³å‡äº®åº¦
                        const centerX = Math.floor(gray.width / 2);
                        const centerY = Math.floor(gray.height / 2);
                        const sampleSize = 50;
                        let sum = 0, count = 0;
                        
                        for (let y = centerY - sampleSize; y < centerY + sampleSize; y++) {
                            for (let x = centerX - sampleSize; x < centerX + sampleSize; x++) {
                                if (x >= 0 && x < gray.width && y >= 0 && y < gray.height) {
                                    sum += gray.data[y * gray.width + x];
                                    count++;
                                }
                            }
                        }
                        
                        const avgBrightness = sum / count;
                        // å¦‚æœèƒŒæ™¯è¾ƒäº®ï¼ˆåŸ¹å…»çš¿ï¼‰ï¼ŒèŒè½è¾ƒæš—ï¼Œéœ€è¦åç›¸
                        needInvert = avgBrightness > 128;
                        log(`è‡ªåŠ¨åˆ¤æ–­: å¹³å‡äº®åº¦=${avgBrightness.toFixed(1)}, åç›¸=${needInvert}`);
                    } else {
                        needInvert = params.invertMode === 'inverted';
                    }
                    
                    // 5. é˜ˆå€¼å¤„ç†
                    let binary = ImageUtils.threshold(gray, params.threshold, needInvert);
                    log('é˜ˆå€¼å¤„ç†å®Œæˆ');
                    
                    // 6. å½¢æ€å­¦æ“ä½œï¼ˆå…ˆè†¨èƒ€åè…èš€ = é—­è¿ç®—ï¼Œè¿æ¥æ–­è£‚åŒºåŸŸï¼‰
                    if (params.morphIterations > 0) {
                        binary = ImageUtils.dilate(binary, params.morphIterations);
                        binary = ImageUtils.erode(binary, params.morphIterations);
                        log('å½¢æ€å­¦æ“ä½œå®Œæˆ');
                    }
                    
                    // 7. æŸ¥æ‰¾è½®å»“
                    const contours = ImageUtils.findContours(binary);
                    log(`æ‰¾åˆ° ${contours.length} ä¸ªåŸå§‹è½®å»“`);
                    
                    // 8. è¿‡æ»¤å’Œè½¬æ¢ä¸ºèŒè½å¯¹è±¡
                    let detected = [];
                    for (let i = 0; i < contours.length; i++) {
                        const contour = contours[i];
                        
                        // é¢ç§¯è¿‡æ»¤
                        if (contour.area < params.minArea || contour.area > params.maxArea) {
                            continue;
                        }
                        
                        // åœ†å½¢åº¦è¿‡æ»¤
                        const circularity = ImageUtils.calculateCircularity(contour);
                        if (circularity < params.circularity) {
                            continue;
                        }
                        
                        // è®¡ç®—ä¸­å¿ƒç‚¹å’Œç­‰æ•ˆåŠå¾„
                        let sumX = 0, sumY = 0;
                        for (const p of contour.points) {
                            sumX += p.x;
                            sumY += p.y;
                        }
                        
                        const centerX = sumX / contour.points.length;
                        const centerY = sumY / contour.points.length;
                        const radius = Math.sqrt(contour.area / Math.PI);
                        
                        detected.push({
                            id: i,
                            x: centerX,
                            y: centerY,
                            radius: radius,
                            area: contour.area,
                            circularity: circularity,
                            confidence: circularity, // ç”¨åœ†å½¢åº¦ä½œä¸ºç½®ä¿¡åº¦
                            manual: false
                        });
                    }
                    
                    log(`è¿‡æ»¤åå‰©ä½™ ${detected.length} ä¸ªå€™é€‰`);
                    
                    // 9. ROIè¿‡æ»¤
                    if (roiCenter && roiRadius) {
                        detected = detected.filter(c => {
                            const dx = c.x - roiCenter.x;
                            const dy = c.y - roiCenter.y;
                            return (dx*dx + dy*dy) <= (roiRadius * roiRadius);
                        });
                        log(`ROIè¿‡æ»¤åå‰©ä½™ ${detected.length} ä¸ª`);
                    }
                    
                    // 10. NMSåˆå¹¶
                    detected = nonMaxSuppression(detected, params.mergeDist);
                    log(`NMSåå‰©ä½™ ${detected.length} ä¸ª`);
                    
                    colonies = detected;
                    
                    // æ˜¾ç¤ºç»“æœ
                    renderMarkers();
                    updateStats();
                    
                    // æ˜¾ç¤ºè°ƒè¯•å›¾åƒï¼ˆå¯é€‰ï¼‰
                    // visualizeProcessing(binary);
                    
                    showToast(`âœ… CVç®—æ³•æ£€æµ‹åˆ° ${colonies.length} ä¸ªèŒè½`);
                    log('åˆ†æå®Œæˆ');
                    
                } catch (err) {
                    console.error(err);
                    log('é”™è¯¯: ' + err.message);
                    showToast('âŒ åˆ†æå¤±è´¥: ' + err.message);
                }
                
                document.getElementById('loadingOverlay').classList.remove('active');
            }, 100);
        }
        
        // NMSåˆå¹¶
        function nonMaxSuppression(detections, minDist) {
            if (detections.length < 2) return detections;
            
            detections.sort((a, b) => b.confidence - a.confidence);
            const result = [];
            const suppressed = new Array(detections.length).fill(false);
            
            for (let i = 0; i < detections.length; i++) {
                if (suppressed[i]) continue;
                
                result.push(detections[i]);
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed[j]) continue;
                    
                    const dx = detections[i].x - detections[j].x;
                    const dy = detections[i].y - detections[j].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < minDist || dist < (detections[i].radius + detections[j].radius)) {
                        suppressed[j] = true;
                    }
                }
            }
            
            return result;
        }
        
        // ==================== YOLOç®—æ³• ====================
        
        async function analyzeYOLO() {
            if (!currentImage) {
                showToast('âŒ æ²¡æœ‰å›¾åƒ');
                return;
            }
            
            if (!modelLoaded || !session) {
                showToast('â³ YOLOæ¨¡å‹æœªå°±ç»ªï¼Œåˆ‡æ¢åˆ°CVæ¨¡å¼');
                useYOLO = false;
                updateAlgoUI();
                analyzeCV();
                return;
            }
            
            document.getElementById('loadingOverlay').classList.add('active');
            document.getElementById('overlayLoadingText').textContent = 'YOLOåˆ†æä¸­...';
            document.getElementById('overlayLoadingSub').textContent = 'ç¥ç»ç½‘ç»œæ¨ç†';
            
            setTimeout(async () => {
                try {
                    const confThreshold = parseFloat(document.getElementById('confThreshold').value);
                    const iouThreshold = parseFloat(document.getElementById('iouThreshold').value);
                    const inputSize = parseInt(document.getElementById('inputSize').value);
                    const contrast = parseFloat(document.getElementById('contrast').value);
                    
                    const tensor = await preprocessImage(currentImage, inputSize, contrast, 0);
                    const feeds = { images: tensor };
                    const results = await session.run(feeds);
                    
                    const output = results.output0 || results[Object.keys(results)[0]];
                    const detections = parseYOLOOutput(output, confThreshold, iouThreshold, inputSize);
                    
                    const scaleX = currentImage.width / inputSize;
                    const scaleY = currentImage.height / inputSize;
                    
                    let detected = detections.map((det, idx) => {
                        const boxWidth = det.x2 - det.x1;
                        const boxHeight = det.y2 - det.y1;
                        const radius = Math.sqrt(boxWidth * boxHeight) / 2;
                        
                        return {
                            id: idx,
                            x: (det.x1 + det.x2) / 2 * scaleX,
                            y: (det.y1 + det.y2) / 2 * scaleY,
                            radius: radius * Math.max(scaleX, scaleY),
                            confidence: det.confidence,
                            manual: false
                        };
                    });
                    
                    if (roiCenter && roiRadius) {
                        detected = detected.filter(c => {
                            const dx = c.x - roiCenter.x;
                            const dy = c.y - roiCenter.y;
                            return (dx*dx + dy*dy) <= (roiRadius * roiRadius);
                        });
                    }
                    
                    colonies = detected;
                    tensor.dispose();
                    
                    renderMarkers();
                    updateStats();
                    showToast(`âœ… YOLOæ£€æµ‹åˆ° ${colonies.length} ä¸ªèŒè½`);
                    
                } catch (err) {
                    console.error(err);
                    showToast('âŒ YOLOå¤±è´¥ï¼Œå°è¯•CVç®—æ³•');
                    analyzeCV();
                }
                
                document.getElementById('loadingOverlay').classList.remove('active');
            }, 100);
        }
        
        async function preprocessImage(img, inputSize, contrast, brightness) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = inputSize;
            tempCanvas.height = inputSize;
            const tCtx = tempCanvas.getContext('2d');
            
            const scale = Math.min(inputSize / img.width, inputSize / img.height);
            const newWidth = img.width * scale;
            const newHeight = img.height * scale;
            const padX = (inputSize - newWidth) / 2;
            const padY = (inputSize - newHeight) / 2;
            
            tCtx.fillStyle = '#808080';
            tCtx.fillRect(0, 0, inputSize, inputSize);
            tCtx.filter = `contrast(${contrast}) brightness(${100 + brightness}%)`;
            tCtx.drawImage(img, padX, padY, newWidth, newHeight);
            
            const imageData = tCtx.getImageData(0, 0, inputSize, inputSize);
            const data = imageData.data;
            
            const red = [], green = [], blue = [];
            for (let i = 0; i < data.length; i += 4) {
                red.push(data[i] / 255);
                green.push(data[i + 1] / 255);
                blue.push(data[i + 2] / 255);
            }
            
            const inputData = new Float32Array(red.concat(green).concat(blue));
            return new ort.Tensor('float32', inputData, [1, 3, inputSize, inputSize]);
        }
        
        function parseYOLOOutput(output, confThreshold, iouThreshold, inputSize) {
            const data = output.data;
            const dims = output.dims;
            const numClasses = dims[1] - 4;
            const numBoxes = dims[2];
            
            let boxes = [];
            for (let i = 0; i < numBoxes; i++) {
                const cx = data[i];
                const cy = data[numBoxes + i];
                const w = data[2 * numBoxes + i];
                const h = data[3 * numBoxes + i];
                
                let maxConf = 0;
                for (let c = 0; c < numClasses; c++) {
                    const conf = data[(4 + c) * numBoxes + i];
                    if (conf > maxConf) maxConf = conf;
                }
                
                if (maxConf > confThreshold) {
                    const x1 = (cx - w / 2) * inputSize;
                    const y1 = (cy - h / 2) * inputSize;
                    const x2 = (cx + w / 2) * inputSize;
                    const y2 = (cy + h / 2) * inputSize;
                    boxes.push({ x1, y1, x2, y2, confidence: maxConf });
                }
            }
            
            return applyNMS(boxes, iouThreshold);
        }
        
        function applyNMS(boxes, iouThreshold) {
            if (boxes.length === 0) return [];
            boxes.sort((a, b) => b.confidence - a.confidence);
            
            const picked = [];
            const suppressed = new Array(boxes.length).fill(false);
            
            for (let i = 0; i < boxes.length; i++) {
                if (suppressed[i]) continue;
                picked.push(boxes[i]);
                
                for (let j = i + 1; j < boxes.length; j++) {
                    if (suppressed[j]) continue;
                    
                    const x1 = Math.max(boxes[i].x1, boxes[j].x1);
                    const y1 = Math.max(boxes[i].y1, boxes[j].y1);
                    const x2 = Math.min(boxes[i].x2, boxes[j].x2);
                    const y2 = Math.min(boxes[i].y2, boxes[j].y2);
                    
                    const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                    const area1 = (boxes[i].x2 - boxes[i].x1) * (boxes[i].y2 - boxes[i].y1);
                    const area2 = (boxes[j].x2 - boxes[j].x1) * (boxes[j].y2 - boxes[j].y1);
                    const union = area1 + area2 - intersection;
                    
                    if (union > 0 && intersection / union > iouThreshold) {
                        suppressed[j] = true;
                    }
                }
            }
            
            return picked;
        }
        
        // ==================== é€šç”¨åŠŸèƒ½ ====================
        
        function displayImage(img) {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // ä¿å­˜åŸå§‹å›¾åƒæ•°æ®
            originalImageData = ctx.getImageData(0, 0, img.width, img.height);
            
            canvas.dataset.origWidth = img.width;
            canvas.dataset.origHeight = img.height;
            
            const containerWidth = imageWrapper.clientWidth;
            let fitScale = containerWidth / img.width;
            fitScale = Math.min(3.0, Math.max(0.05, fitScale));
            document.getElementById('zoomSlider').value = fitScale.toFixed(2);
            document.getElementById('zoomValue').textContent = fitScale.toFixed(2);
            applyZoom();
        }
        
        function applyZoom() {
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            canvas.style.width = (canvas.width * zoom) + 'px';
            canvas.style.height = (canvas.height * zoom) + 'px';
            renderMarkers();
        }
        
        function renderMarkers() {
            overlayLayer.innerHTML = '';
            overlayLayer.appendChild(roiVisual);
            
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            
            colonies.forEach((colony, idx) => {
                const marker = document.createElement('div');
                marker.className = `colony-marker ${colony.manual ? 'manual' : ''}`;
                marker.style.left = (colony.x * zoom) + 'px';
                marker.style.top = (colony.y * zoom) + 'px';
                
                if (showCircles) {
                    const circle = document.createElement('div');
                    circle.className = 'marker-circle';
                    circle.style.width = (colony.radius * zoom * 2) + 'px';
                    circle.style.height = (colony.radius * zoom * 2) + 'px';
                    marker.appendChild(circle);
                }
                
                const center = document.createElement('div');
                center.className = 'marker-center';
                marker.appendChild(center);
                
                const tooltip = document.createElement('div');
                tooltip.className = 'marker-tooltip';
                const confText = colony.confidence ? ` | ${(colony.confidence * 100).toFixed(0)}%` : '';
                const areaText = colony.area ? ` | A:${colony.area}` : '';
                tooltip.textContent = `#${idx + 1} | r=${Math.round(colony.radius)}${confText}${areaText}`;
                marker.appendChild(tooltip);
                
                marker.onclick = (e) => { e.stopPropagation(); removeColony(idx); };
                overlayLayer.appendChild(marker);
            });
            
            if (roiCenter && roiRadius) updateRoiVisual();
        }
        
        function updateStats() {
            const auto = colonies.filter(c => !c.manual).length;
            const manual = colonies.filter(c => c.manual).length;
            const avgRadius = colonies.length > 0 ? 
                (colonies.reduce((sum, c) => sum + c.radius, 0) / colonies.length).toFixed(1) : 0;
            
            document.getElementById('statTotal').textContent = colonies.length;
            document.getElementById('statAuto').textContent = auto;
            document.getElementById('statManual').textContent = manual;
            document.getElementById('statAvgRadius').textContent = avgRadius;
        }
        
        function removeColony(index) {
            colonies.splice(index, 1);
            colonies.forEach((c, idx) => c.id = idx);
            renderMarkers();
            updateStats();
            showToast('ğŸ—‘ï¸ å·²åˆ é™¤');
        }
        
        // ==================== äº‹ä»¶å¤„ç† ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            // é»˜è®¤è¿›å…¥CVæ¨¡å¼
            updateAlgoUI();
            
            document.getElementById('fileInput').addEventListener('change', handleFile);
            document.getElementById('cameraInput').addEventListener('change', handleFile);
            
            uploadCard.addEventListener('dragover', (e) => { 
                e.preventDefault(); 
                uploadCard.classList.add('active'); 
            });
            uploadCard.addEventListener('dragleave', () => uploadCard.classList.remove('active'));
            uploadCard.addEventListener('drop', (e) => { 
                e.preventDefault(); 
                uploadCard.classList.remove('active'); 
                if (e.dataTransfer.files.length) processFile(e.dataTransfer.files[0]); 
            });
            
            // æ»‘å—äº‹ä»¶
            ['threshold', 'minArea', 'maxArea', 'circularity', 'morphIterations', 
             'contrast', 'blurRadius', 'mergeDist', 'confThreshold', 'iouThreshold'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', (e) => {
                        const displayId = id + 'Value';
                        const displayEl = document.getElementById(displayId);
                        if (displayEl) displayEl.textContent = e.target.value;
                    });
                }
            });
            
            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                document.getElementById('zoomValue').textContent = parseFloat(e.target.value).toFixed(2);
                applyZoom();
            });
            
            // æŒ‰é’®
            document.getElementById('analyzeBtn').addEventListener('click', () => {
                if (useYOLO && modelLoaded) analyzeYOLO();
                else analyzeCV();
            });
            
            document.getElementById('addModeBtn').addEventListener('click', toggleAddMode);
            document.getElementById('toggleCirclesBtn').addEventListener('click', toggleCircles);
            document.getElementById('clearBtn').addEventListener('click', clearAll);
            document.getElementById('backBtn').addEventListener('click', resetApp);
            document.getElementById('selectRoiBtn').addEventListener('click', enterRoiMode);
            document.getElementById('clearRoiBtn').addEventListener('click', clearRoi);
            document.getElementById('exportImgBtn').addEventListener('click', exportImage);
            document.getElementById('resetParamsBtn').addEventListener('click', resetToDefault);
            
            // Canvasäº‹ä»¶
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', cancelRoiDraw);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', cancelRoiDraw);
        });
        
        function handleFile(e) { 
            if (e.target.files.length) processFile(e.target.files[0]); 
        }
        
        function processFile(file) {
            if (!file.type.startsWith('image/')) { 
                showToast('âŒ è¯·é€‰æ‹©å›¾ç‰‡'); 
                return; 
            }
            
            log('åŠ è½½å›¾ç‰‡: ' + file.name);
            
            const reader = new FileReader();
            reader.onload = (e) => { 
                const img = new Image(); 
                img.onload = () => { 
                    currentImage = img; 
                    displayImage(img);
                    
                    log(`å›¾ç‰‡å°ºå¯¸: ${img.width}x${img.height}`);
                    
                    // è‡ªåŠ¨åˆ†æ
                    if (useYOLO && modelLoaded) analyzeYOLO();
                    else analyzeCV();
                }; 
                img.src = e.target.result; 
            };
            reader.readAsDataURL(file);
            
            uploadCard.style.display = 'none';
            viewer.classList.add('active');
        }
        
        // ROIåŠŸèƒ½
        function enterRoiMode() { 
            if (!currentImage) return; 
            isRoiMode = true; 
            canvas.style.cursor = 'crosshair'; 
            showToast('æŒ‰ä¸‹/è§¦æ‘¸ç¡®å®šåœ†å¿ƒï¼Œæ‹–åŠ¨è®¾å®šåŠå¾„'); 
        }
        
        function clearRoi() { 
            roiCenter = null; 
            roiRadius = null; 
            roiVisual.style.display = 'none'; 
            document.getElementById('roiIndicator').style.display = 'none'; 
            showToast('ROIå·²æ¸…é™¤'); 
        }
        
        function updateRoiVisual() {
            if (!roiCenter || !roiRadius) { 
                roiVisual.style.display = 'none'; 
                return; 
            }
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            roiVisual.style.left = ((roiCenter.x - roiRadius) * zoom) + 'px';
            roiVisual.style.top = ((roiCenter.y - roiRadius) * zoom) + 'px';
            roiVisual.style.width = (roiRadius * 2 * zoom) + 'px';
            roiVisual.style.height = (roiRadius * 2 * zoom) + 'px';
            roiVisual.style.display = 'block';
            document.getElementById('roiIndicator').style.display = 'inline-flex';
        }
        
        function getImageCoordsFromEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) { 
                clientX = e.touches[0].clientX; 
                clientY = e.touches[0].clientY; 
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else { 
                clientX = e.clientX; 
                clientY = e.clientY; 
            }
            return { 
                x: (clientX - rect.left) / zoom, 
                y: (clientY - rect.top) / zoom 
            };
        }
        
        function handleCanvasMouseDown(e) { 
            if (!isRoiMode) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            roiStart = { x, y }; 
            roiVisual.style.display = 'block'; 
        }
        
        function handleCanvasMouseMove(e) { 
            if (!isRoiMode || !roiStart) return; 
            e.preventDefault(); 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            const zoom = parseFloat(document.getElementById('zoomSlider').value); 
            roiVisual.style.left = ((roiStart.x - radius) * zoom) + 'px'; 
            roiVisual.style.top = ((roiStart.y - radius) * zoom) + 'px'; 
            roiVisual.style.width = (radius * 2 * zoom) + 'px'; 
            roiVisual.style.height = (radius * 2 * zoom) + 'px'; 
        }
        
        function handleCanvasMouseUp(e) { 
            if (!isRoiMode || !roiStart) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            if (radius > 2) { 
                roiCenter = { x: roiStart.x, y: roiStart.y }; 
                roiRadius = radius; 
                updateRoiVisual(); 
                showToast(`ROIå·²è®¾ç½®: åŠå¾„${Math.round(radius)}px`); 
            } else { 
                clearRoi(); 
            } 
            isRoiMode = false; 
            roiStart = null; 
            canvas.style.cursor = 'default'; 
        }
        
        function handleTouchStart(e) { 
            if (!isRoiMode) return;
            e.preventDefault(); 
            const { x, y } = getImageCoordsFromEvent(e); 
            roiStart = { x, y }; 
            roiVisual.style.display = 'block'; 
        }
        
        function handleTouchMove(e) { 
            e.preventDefault(); 
            if (!isRoiMode || !roiStart) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            const zoom = parseFloat(document.getElementById('zoomSlider').value); 
            roiVisual.style.left = ((roiStart.x - radius) * zoom) + 'px'; 
            roiVisual.style.top = ((roiStart.y - radius) * zoom) + 'px'; 
            roiVisual.style.width = (radius * 2 * zoom) + 'px'; 
            roiVisual.style.height = (radius * 2 * zoom) + 'px'; 
        }
        
        function handleTouchEnd(e) { 
            e.preventDefault(); 
            if (!isRoiMode || !roiStart) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            if (radius > 2) { 
                roiCenter = { x: roiStart.x, y: roiStart.y }; 
                roiRadius = radius; 
                updateRoiVisual(); 
                showToast(`ROIå·²è®¾ç½®: åŠå¾„${Math.round(radius)}px`); 
            } else { 
                clearRoi(); 
            } 
            isRoiMode = false; 
            roiStart = null; 
            canvas.style.cursor = 'default'; 
        }
        
        function cancelRoiDraw() { 
            if (isRoiMode) { 
                isRoiMode = false; 
                roiStart = null; 
                canvas.style.cursor = 'default'; 
                roiVisual.style.display = roiCenter ? 'block' : 'none'; 
            } 
        }
        
        function toggleAddMode() {
            isAddMode = !isAddMode;
            const btn = document.getElementById('addModeBtn');
            if (isAddMode) { 
                btn.style.background = 'var(--success)'; 
                btn.innerHTML = '<span>âœ“</span><span>å®Œæˆæ·»åŠ </span>'; 
                canvas.style.cursor = 'crosshair'; 
            } else { 
                btn.style.background = ''; 
                btn.innerHTML = '<span>â•</span><span>æ‰‹åŠ¨æ·»åŠ </span>'; 
                canvas.style.cursor = 'default'; 
            }
        }
        
        function toggleCircles() { 
            showCircles = !showCircles; 
            renderMarkers(); 
            showToast(showCircles ? 'â­• æ˜¾ç¤ºåœ†åœˆ' : 'â­• éšè—åœ†åœˆ'); 
        }
        
        function handleCanvasClick(e) {
            if (!isAddMode) return;
            const { x, y } = getImageCoordsFromEvent(e);
            const avgRadius = colonies.length > 0 ? 
                colonies.reduce((sum, c) => sum + c.radius, 0) / colonies.length : 15;
            
            colonies.push({ 
                id: colonies.length, 
                x: x, 
                y: y, 
                radius: avgRadius, 
                confidence: 1.0, 
                manual: true 
            });
            
            renderMarkers(); 
            updateStats(); 
            showToast('âœ… å·²æ·»åŠ ');
        }
        
        function clearAll() { 
            if (confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰æ ‡è®°ï¼Ÿ')) { 
                colonies = []; 
                renderMarkers(); 
                updateStats(); 
                showToast('ğŸ—‘ï¸ å·²æ¸…ç©º'); 
            } 
        }
        
        function resetApp() {
            currentImage = null; 
            originalImageData = null;
            colonies = []; 
            isAddMode = false; 
            clearRoi();
            uploadCard.style.display = 'block'; 
            viewer.classList.remove('active');
            overlayLayer.innerHTML = ''; 
            overlayLayer.appendChild(roiVisual);
            canvas.style.cursor = 'default';
        }
        
        function resetToDefault() {
            // CVå‚æ•°é»˜è®¤å€¼
            document.getElementById('threshold').value = 128;
            document.getElementById('thresholdValue').textContent = '128';
            document.getElementById('minArea').value = 10;
            document.getElementById('minAreaValue').textContent = '10';
            document.getElementById('maxArea').value = 500;
            document.getElementById('maxAreaValue').textContent = '500';
            document.getElementById('circularity').value = 0.7;
            document.getElementById('circularityValue').textContent = '0.7';
            document.getElementById('morphIterations').value = 1;
            document.getElementById('morphValue').textContent = '1';
            document.getElementById('contrast').value = 1.0;
            document.getElementById('contrastValue').textContent = '1.0';
            document.getElementById('blurRadius').value = 1;
            document.getElementById('blurValue').textContent = '1';
            document.getElementById('mergeDist').value = 15;
            document.getElementById('mergeDistValue').textContent = '15';
            
            if (currentImage) {
                const containerWidth = imageWrapper.clientWidth;
                let fitScale = containerWidth / currentImage.width;
                fitScale = Math.min(3.0, Math.max(0.05, fitScale));
                document.getElementById('zoomSlider').value = fitScale.toFixed(2);
                document.getElementById('zoomValue').textContent = fitScale.toFixed(2);
                applyZoom();
                
                analyzeCV();
            }
        }
        
        function exportImage() {
            if (!currentImage) return;
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = currentImage.width; 
            exportCanvas.height = currentImage.height;
            const eCtx = exportCanvas.getContext('2d');
            
            eCtx.drawImage(currentImage, 0, 0);
            
            colonies.forEach(c => {
                eCtx.beginPath(); 
                eCtx.arc(c.x, c.y, c.radius, 0, 2 * Math.PI);
                eCtx.strokeStyle = c.manual ? 'gold' : '#ff4757'; 
                eCtx.lineWidth = 2; 
                eCtx.stroke();
                
                eCtx.beginPath(); 
                eCtx.arc(c.x, c.y, 3, 0, 2 * Math.PI);
                eCtx.fillStyle = c.manual ? 'gold' : '#00ff88'; 
                eCtx.fill();
                
                eCtx.fillStyle = c.manual ? 'gold' : '#00ff88';
                eCtx.font = '12px Arial';
                eCtx.fillText(`#${c.id + 1}`, c.x + c.radius + 5, c.y);
            });
            
            const link = document.createElement('a'); 
            link.download = `colonies_${useYOLO ? 'yolo' : 'cv'}_${Date.now()}.png`; 
            link.href = exportCanvas.toDataURL('image/png'); 
            link.click();
            
            showToast('ğŸ“¸ å›¾ç‰‡å·²å¯¼å‡º');
        }
        
        function showToast(msg) { 
            const toast = document.getElementById('toast'); 
            toast.textContent = msg; 
            toast.classList.add('show'); 
            setTimeout(() => toast.classList.remove('show'), 3000); 
        }
        
        window.addEventListener('resize', () => { 
            if (currentImage && viewer.classList.contains('active')) { 
                const containerWidth = imageWrapper.clientWidth; 
                let fitScale = containerWidth / currentImage.width; 
                fitScale = Math.min(3.0, Math.max(0.05, fitScale)); 
                document.getElementById('zoomSlider').value = fitScale.toFixed(2); 
                document.getElementById('zoomValue').textContent = fitScale.toFixed(2); 
                applyZoom(); 
            } 
        });
    </script>
</body>
</html>
